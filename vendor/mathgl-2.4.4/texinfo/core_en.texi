@c ------------------------------------------------------------------
@chapter MathGL core
@nav{}
@cindex mglGraph

@ifset UDAV
This chapter contains a lot of plotting commands for 1D, 2D and 3D data. It also encapsulates parameters for axes drawing. Moreover an arbitrary coordinate transformation can be used for each axis.  Additional information about colors, fonts, formula parsing can be found in @ref{General concepts}. The full list of symbols used by MathGL for setting up plots can be found in @ref{Symbols for styles}.
@end ifset

@ifclear UDAV
The core of MathGL is @strong{mglGraph} class defined in @code{#include <mgl2/mgl.h>}. It contains a lot of plotting functions for 1D, 2D and 3D data. It also encapsulates parameters for axes drawing. Moreover an arbitrary coordinate transformation can be used for each axis. All plotting functions use data encapsulated in mglData class (see @ref{Data processing}) that allows to check sizes of used arrays easily. Also it have many functions for data handling: modify it by formulas, find momentums and distribution (histogram), apply operator (differentiate, integrate, transpose, Fourier and so on), change data sizes (interpolate, squeeze, crop and so on). Additional information about colors, fonts, formula parsing can be found in @ref{General concepts} and @ref{Other classes}.
@end ifclear

Some of MathGL features will appear only in novel versions. To test used MathGL version you can use following function.
@anchor{version}
@deftypefn {MGL command} {} version 'ver'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{bool} CheckVersion (@code{const char *}ver) static
@deftypefnx {C function} @code{int} mgl_check_version (@code{const char *}ver)
@end ifclear
Return zero if MathGL version is appropriate for required by @var{ver}, i.e. if major version is the same and minor version is greater or equal to one in @var{ver}.
@end deftypefn

@menu
* Constructor::
* Graphics setup::
* Axis settings::
* Subplots and rotation::
* Export picture::
* Background::
* Primitives::
* Text printing::
* Axis and Colorbar::
* Legend::
* 1D plotting::
* 2D plotting::
* 3D plotting::
* Dual plotting::
* Vector fields::
* Other plotting::
* Nonlinear fitting::
* Data manipulation::
@c * IDTF functions::
@end menu

@c ##################################################################
@external{}
@node Constructor, Graphics setup, , MathGL core
@section Create and delete objects
@nav{}

@ifclear UDAV
@deftypefn {Constructor on @code{mglGraph}} {} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
@deftypefnx {Constructor on @code{mglGraph}} {} mglGraph (@code{const mglGraph &}gr)
@deftypefnx {Constructor on @code{mglGraph}} {} mglGraph (@code{HMGL} gr)
@deftypefnx {C function} @code{HMGL} mgl_create_graph (@code{int} width, @code{int} height)
@deftypefnx {C function} @code{HMGL} mgl_create_graph_gl ()
Creates the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{kind} may have following values: @samp{0} -- use default plotter, @samp{1} -- use OpenGL plotter.
@end deftypefn

@deftypefn {Destructor on @code{mglGraph}} {} ~mglGraph ()
@deftypefnx {C function} @code{HMGL} mgl_delete_graph (@code{HMGL} gr)
Deletes the instance of class mglGraph.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{HMGL} Self ()
Returns the pointer to internal object of type @code{HMGL}.
@end deftypefn
@end ifclear

@ifset UDAV
You don't need to create canvas object in MGL.
@end ifset

@c ##################################################################
@external{}
@node Graphics setup, Axis settings, Constructor, MathGL core
@section Graphics setup
@nav{}
@cindex MathGL setup

Functions and variables in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@anchor{reset}
@deftypefn {MGL command} {} reset
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} DefaultPlotParam ()
@deftypefnx {C function} @code{void} mgl_set_def_param (@code{HMGL} gr)
@end ifclear
Restore initial values for all of parameters and clear the image.
@end deftypefn

@anchor{setup}
@deftypefn {MGL command} {} setup @code{val flag}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetFlagAdv (@code{int} val, @code{uint32_t} flag)
@deftypefnx {C function} @code{void} mgl_set_flag (@code{HMGL} gr, @code{int} val, @code{uint32_t} flag)
@end ifclear
Sets the value of internal binary @var{flag} to @var{val}. The list of flags can be found at @url{https://sourceforge.net/p/mathgl/code/HEAD/tree/mathgl-2x/include/mgl2/define.h#l267, define.h}. The current list of flags are: 
@verbatim
#define MGL_ENABLE_CUT		0x00000004 	///< Flag which determines how points outside bounding box are drown.
#define MGL_ENABLE_RTEXT 	0x00000008 	///< Use text rotation along axis
#define MGL_AUTO_FACTOR		0x00000010 	///< Enable autochange PlotFactor
#define MGL_ENABLE_ALPHA 	0x00000020 	///< Flag that Alpha is used
#define MGL_ENABLE_LIGHT 	0x00000040 	///< Flag of using lightning
#define MGL_TICKS_ROTATE 	0x00000080 	///< Allow ticks rotation
#define MGL_TICKS_SKIP		0x00000100 	///< Allow ticks rotation
#define MGL_DISABLE_SCALE	0x00000200 	///< Temporary flag for disable scaling (used for axis)
#define MGL_FINISHED 		0x00000400 	///< Flag that final picture (i.e. mglCanvas::G) is ready
#define MGL_USE_GMTIME		0x00000800 	///< Use gmtime instead of localtime
#define MGL_SHOW_POS		0x00001000 	///< Switch to show or not mouse click position
#define MGL_CLF_ON_UPD		0x00002000 	///< Clear plot before Update()
#define MGL_NOSUBTICKS		0x00004000 	///< Disable subticks drawing (for bounding box)
#define MGL_LOCAL_LIGHT		0x00008000 	///< Keep light sources for each inplot
#define MGL_VECT_FRAME		0x00010000 	///< Use DrwDat to remember all data of frames
#define MGL_REDUCEACC		0x00020000 	///< Reduce accuracy of points (to reduce size of output files)
#define MGL_PREFERVC 		0x00040000 	///< Prefer vertex color instead of texture if output format supports
#define MGL_ONESIDED 		0x00080000 	///< Render only front side of surfaces if output format supports (for debugging)
#define MGL_NO_ORIGIN 		0x00100000 	///< Don't draw tick labels at axis origin
#define MGL_GRAY_MODE 		0x00200000 	///< Convert all colors to gray ones
#define MGL_FULL_CURV 		0x00400000 	///< Disable omitting points in straight-line part(s)
#define MGL_NO_SCALE_REL 	0x00800000 	///< Disable font scaling in relative inplots
@end verbatim
@end deftypefn

@ifclear UDAV
@deftypefn {C function} @code{void} mgl_bsize (@code{unsigned} bsize)
Set buffer size for number of primitives as (1<<bsize)^2. I.e. as 10^12 for bsize=20 or 4*10^9 for bsize=16 (default). NOTE: you set it only once before any plotting. The current value is returned.
@end deftypefn
@end ifclear


@menu
* Transparency::
* Lighting::
* Fog::
* Default sizes::
* Cutting::
* Font settings::
* Palette and colors::
* Masks::
* Error handling::
* Stop drawing::
@end menu

@c ==================================================================
@external{}
@node Transparency, Lighting, , Graphics setup
@subsection Transparency
@nav{}
@cindex Alpha
@ifclear UDAV
@cindex SetAlphaDef
@cindex SetTranspType
@end ifclear
@cindex AlphaDef
@cindex TranspType

There are several functions and variables for setup transparency. The general function is @ref{alpha} which switch on/off the transparency for overall plot. It influence only for graphics which created after @ref{alpha} call (with one exception, OpenGL). Function @ref{alphadef} specify the default value of alpha-channel. Finally, function @ref{transptype} set the kind of transparency. @sref{Transparency and lighting}

@anchor{alpha}
@deftypefn {MGL command} {} alpha @code{[val=on]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Alpha (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_alpha (@code{HMGL} gr, @code{int} enable)
@end ifclear
Sets the transparency on/off and returns previous value of transparency. It is recommended to call this function before any plotting command. Default value is transparency off.
@end deftypefn

@anchor{alphadef}
@deftypefn {MGL command} {} alphadef @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAlphaDef (@code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_alpha_default (@code{HMGL} gr, @code{mreal} alpha)
@end ifclear
Sets default value of alpha channel (transparency) for all plotting functions. Initial value is 0.5.
@end deftypefn

@anchor{transptype}
@deftypefn {MGL command} {} transptype @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTranspType (@code{int} type)
@deftypefnx {C function} @code{void} mgl_set_transp_type (@code{HMGL} gr, @code{int} type)
@end ifclear
Set the type of transparency. Possible values are:
@itemize @bullet
@item
Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces.
@item
Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel.
@item
Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{SetAlphaDef(0.3)} or less for lamp-like transparency.
@end itemize
@sref{Types of transparency}.
@end deftypefn

@c ==================================================================
@external{}
@node Lighting, Fog, Transparency, Graphics setup
@subsection Lighting
@nav{}

@ifclear UDAV
@cindex SetAmbient
@cindex AddLight
@end ifclear
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @ref{light} which switch on/off the lighting for overall plot. It influence only for graphics which created after @ref{light} call (with one exception, OpenGL). Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot. @sref{Lighting sample}

@anchor{light}
@deftypefn {MGL command} {} light @code{[val=on]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{bool} Light (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light (@code{HMGL} gr, @code{int} enable)
@end ifclear
Sets the using of light on/off for overall plot. Function returns previous value of lighting. Default value is lightning off.
@end deftypefn

@deftypefn {MGL command} {} light @code{num} @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Light (@code{int} n, @code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light_n (@code{HMGL} gr, @code{int} n, @code{int} enable)
@end ifclear
Switch on/off @var{n}-th light source separately.
@end deftypefn

@deftypefn {MGL command} {} light @code{num xdir ydir zdir} ['col'='w' @code{br=0.5}]
@deftypefnx {MGL command} {} light @code{num xdir ydir zdir xpos ypos zpos} ['col'='w' @code{br=0.5 ap=0}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{mreal} bright=@code{0.5}, @code{mreal} ap=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} r, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{mreal} bright=@code{0.5}, @code{mreal} ap=@code{0})
@deftypefnx {C function} @code{void} mgl_add_light (@code{HMGL} gr, @code{int} n, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz)
@deftypefnx {C function} @code{void} mgl_add_light_ext (@code{HMGL} gr, @code{int} n, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{char} c, @code{mreal} bright, @code{mreal} ap)
@deftypefnx {C function} @code{void} mgl_add_light_loc (@code{HMGL} gr, @code{int} n, @code{mreal} rx, @code{mreal} ry, @code{mreal} rz, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{char} c, @code{mreal} bright, @code{mreal} ap)
@end ifclear
The function adds a light source with identification @var{n} in direction @var{d} with color @var{c} and with brightness @var{bright} (which must be in range [0,1]). If position @var{r} is specified and isn't NAN then light source is supposed to be local otherwise light source is supposed to be placed at infinity.
@end deftypefn

@anchor{diffuse}
@deftypefn {MGL command} {} diffuse @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetDiffuse (@code{mreal} bright)
@deftypefnx {C function} @code{void} mgl_set_difbr (@code{HMGL} gr, @code{mreal} bright)
@end ifclear
Set brightness of diffusive light (only for local light sources).
@end deftypefn

@anchor{ambient}
@deftypefn {MGL command} {} ambient @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAmbient (@code{mreal} bright=@code{0.5})
@deftypefnx {C function} @code{void} mgl_set_ambbr (@code{HMGL} gr, @code{mreal} bright)
@end ifclear
Sets the brightness of ambient light. The value should be in range [0,1].
@end deftypefn

@anchor{attachlight}
@deftypefn {MGL command} {} attachlight @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} AttachLight (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_attach_light (@code{HMGL} gr, @code{int} val)
@end ifclear
Set to attach light settings to @ref{inplot}/@ref{subplot}. Note, OpenGL and some output formats don't support this feature.
@end deftypefn

@c ==================================================================
@external{}
@node Fog, Default sizes, Lighting, Graphics setup
@subsection Fog
@nav{}
@cindex Fog

@anchor{fog}
@deftypefn {MGL command} {} fog @code{val [dz=0.25]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fog (@code{mreal} d, @code{mreal} dz=@code{0.25})
@deftypefnx {C function} @code{void} mgl_set_fog (@code{HMGL} gr, @code{mreal} d, @code{mreal} dz)
@end ifclear
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. Note, that fog was applied at stage of image creation, not at stage of drawing. @sref{Adding fog}
@end deftypefn

@c ==================================================================
@external{}
@node Default sizes, Cutting, Fog, Graphics setup
@subsection Default sizes
@nav{}
@ifclear UDAV
@cindex SetBarWidth
@cindex SetMarkSize
@cindex SetArrowSize
@cindex SetMeshNum
@cindex SetPlotId
@end ifclear
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex MeshNum

These variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, line width and so on. As any other settings these ones will influence only on plots created after the settings change.

@anchor{barwidth}
@deftypefn {MGL command} {} barwidth @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetBarWidth ( @code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_bar_width (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Sets relative width of rectangles in @ref{bars}, @ref{barh}, @ref{boxplot}, @ref{candle}, @ref{ohlc}. Default value is @code{0.7}.
@end deftypefn

@anchor{marksize}
@deftypefn {MGL command} {} marksize @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMarkSize (@code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_mark_size (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Sets size of marks for @ref{1D plotting}. Default value is @code{1}.
@end deftypefn

@anchor{arrowsize}
@deftypefn {MGL command} {} arrowsize @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetArrowSize (@code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_arrow_size (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Sets size of arrows for @ref{1D plotting}, lines and curves (see @ref{Primitives}). Default value is @code{1}.
@end deftypefn

@anchor{meshnum}
@anchor{MeshNum}
@deftypefn {MGL command} {} meshnum @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMeshNum (@code{int} val)
@deftypefnx {C function} @code{void} mgl_set_meshnum (@code{HMGL} gr, @code{int} num)
@end ifclear
Sets approximate number of lines in @ref{mesh}, @ref{fall}, @ref{grid2}, and also the number of hachures in @ref{vect}, @ref{dew}, and the number of cells in @ref{cloud}, and the number of markers in @ref{plot}, @ref{tens}, @ref{step}, @ref{mark}, @ref{textmark}. By default (=0) it draws all lines/hachures/cells/markers.
@end deftypefn

@anchor{facenum}
@deftypefn {MGL command} {} facenum @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetFaceNum (@code{int} val)
@deftypefnx {C function} @code{void} mgl_set_facenum (@code{HMGL} gr, @code{int} num)
@end ifclear
Sets approximate number of visible faces. Can be used for speeding up drawing by cost of lower quality. By default (=0) it draws all of them.
@end deftypefn

@anchor{plotid}
@deftypefn {MGL command} {} plotid 'id'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetPlotId (@code{const char *}id)
@deftypefnx {C function} @code{void} mgl_set_plotid (@code{HMGL} gr, @code{const char *}id)
@end ifclear
Sets default name @var{id} as filename for saving (in FLTK window for example).
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{const char *} GetPlotId ()
@deftypefnx {C function only} @code{const char *} mgl_get_plotid (@code{HMGL} gr)
@deftypefnx {Fortran subroutine} @code{} mgl_get_plotid (@code{long} gr, @code{char *}out, @code{int} len)
Gets default name @var{id} as filename for saving (in FLTK window for example).
@end deftypefn
@end ifclear

@anchor{pendelta}
@deftypefn {MGL command} {} pendelta @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetPenDelta (@code{double} val)
@deftypefnx {C function} @code{void} mgl_pen_delta (@code{HMGL} gr, @code{double} val)
@end ifclear
Changes the blur around lines and text (default is 1). For @var{val}>1 the text and lines are more sharped. For @var{val}<1 the text and lines are more blurred.
@end deftypefn

@c ==================================================================
@external{}
@node Cutting, Font settings, Default sizes, Graphics setup
@subsection Cutting
@nav{}
@ifclear UDAV
@cindex SetCut
@cindex SetCutBox
@cindex CutOff
@end ifclear
@cindex Cut

These variables and functions set the condition when the points are excluded (cutted) from the drawing. Note, that a point with NAN value(s) of coordinate or amplitude will be automatically excluded from the drawing. @sref{Cutting sample}

@anchor{cut}
@deftypefn {MGL command} {} cut @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCut (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_cut (@code{HMGL} gr, @code{int} val)
@end ifclear
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypefn

@deftypefn {MGL command} {} cut @code{x1 y1 z1 x2 y2 z2}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCutBox (@code{mglPoint} p1, @code{mglPoint} p1)
@deftypefnx {C function} @code{void} mgl_set_cut_box (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2)
@end ifclear
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty.
@end deftypefn

@deftypefn {MGL command} {} cut 'cond'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} CutOff (@code{const char *}cond)
@deftypefnx {C function} @code{void} mgl_set_cutoff (@code{HMGL} gr, @code{const char *}cond)
@end ifclear
Sets the cutting off condition by formula @var{cond}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{""} to disable cutting off condition.
@end deftypefn

@c ==================================================================
@external{}
@node Font settings, Palette and colors, Cutting, Graphics setup
@subsection Font settings
@nav{}
@ifclear UDAV
@cindex SetFontSize
@cindex SetFontDef
@cindex SetRotatedText
@cindex SetFontSizePT
@cindex SetFontSizeCM
@cindex SetFontSizeIN
@cindex LoadFont
@cindex CopyFont
@cindex RestoreFont
@end ifclear
@cindex Font
@cindex RotateText

@anchor{font}
@deftypefn {MGL command} {} font 'fnt' [@code{val=6}]
Font style for text and labels (see text). Initial style is 'fnt'=':rC' give Roman font with centering. Parameter @code{val} sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels. For more detail, see @ref{Font styles}.
@end deftypefn

@anchor{rotatetext}
@deftypefn {MGL command} {} rotatetext @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRotatedText (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_rotated_text (@code{HMGL} gr, @code{int} val)
@end ifclear
Sets to use or not text rotation.
@end deftypefn

@anchor{scaletext}
@deftypefn {MGL command} {} scaletext @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetScaleText (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_scale_text (@code{HMGL} gr, @code{int} val)
@end ifclear
Sets to scale text in relative @ref{inplot} (including @ref{columnplot}, @ref{gridplot}, @ref{stickplot}, @ref{shearplot}) or not.
@end deftypefn

@anchor{loadfont}
@deftypefn {MGL command} {} loadfont ['name'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{""})
@deftypefnx {C function} @code{void} mgl_load_font (@code{HMGL} gr, @code{const char *}name, @code{const char *}path)
@end ifclear
Load font typeface from @var{path}/@var{name}. Empty name will load default font.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetFontDef (@code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_set_font_def (@code{HMGL} gr, @code{const char *} val)
Sets the font specification (see @ref{Text printing}). Default is @samp{rC} -- Roman font centering.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetFontSize (@code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_font_size (@code{HMGL} gr, @code{mreal} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetFontSizePT (@code{mreal} cm, @code{int} dpi=@code{72})
Set FontSize by size in pt and picture DPI (default is 16 pt for dpi=72).
@end deftypefn
@deftypefn {Method on @code{mglGraph}} @code{inline void} SetFontSizeCM (@code{mreal} cm, @code{int} dpi=@code{72})
Set FontSize by size in centimeters and picture DPI (default is 0.56 cm = 16 pt).
@end deftypefn
@deftypefn {Method on @code{mglGraph}} @code{inline void} SetFontSizeIN (@code{mreal} cm, @code{int} dpi=@code{72})
Set FontSize by size in inch and picture DPI (default is 0.22 in = 16 pt).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} CopyFont (@code{mglGraph *} from)
@deftypefnx {C function} @code{void} mgl_copy_font (@code{HMGL} gr, @code{HMGL} gr_from)
Copy font data from another @code{mglGraph} object.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} RestoreFont ()
@deftypefnx {C function} @code{void} mgl_restore_font (@code{HMGL} gr)
Restore font data to default typeface.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetDefFont (@code{const char *}name, @code{const char *}path=@code{""}) static
@deftypefnx {C function} @code{void} mgl_def_font (@code{const char *}name, @code{const char *}path)
Load default font typeface (for all newly created HMGL/mglGraph objects) from @var{path}/@var{name}.
@end deftypefn

@end ifclear

@c ==================================================================
@external{}
@node Palette and colors, Masks, Font settings, Graphics setup
@subsection Palette and colors
@nav{}
@ifclear UDAV
@cindex SetPalette
@end ifclear
@cindex Palette

@anchor{palette}
@deftypefn {MGL command} {} palette 'colors'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetPalette (@code{const char *}colors)
@deftypefnx {C function} @code{void} mgl_set_palette (@code{HMGL} gr, @code{const char *}colors)
@end ifclear
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (see @ref{1D plotting}) for curves which styles are not specified. Internal color counter will be nullified by any change of palette. This includes even hidden change (for example, by @ref{box} or @ref{axis} functions).
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetDefScheme (@code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_set_def_sch (@code{HMGL} gr, @code{const char *}sch)
Sets the @var{sch} as default color scheme. Default value is @code{"BbcyrR"}.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetColor (@code{char} id, @code{mreal} r, @code{mreal} g, @code{mreal} b) static
@deftypefnx {C function} @code{void} mgl_set_color (@code{char} id, @code{mreal} r, @code{mreal} g, @code{mreal} b)
Sets RGB values for color with given @var{id}. This is global setting which influence on any later usage of symbol @var{id}.
@end deftypefn
@end ifclear


@anchor{gray}
@deftypefn {MGL command} {} gray [@code{val=on}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Gray (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_gray (@code{HMGL} gr, @code{int} enable)
@end ifclear
Sets the gray-scale mode on/off.
@end deftypefn

@c ==================================================================
@external{}
@node Masks, Error handling, Palette and colors, Graphics setup
@subsection Masks
@nav{}
@cindex SetMask
@cindex SetMaskAngle

@anchor{mask}
@deftypefn {MGL command} {} mask 'id' 'hex' [angle]
@deftypefnx {Команда MGL} {} mask 'id' hex [angle]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMask (@code{char} id, @code{const char *}hex)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMask (@code{char} id, @code{uint64_t} hex)
@deftypefnx {C function} @code{void} mgl_set_mask (@code{HMGL} gr, @code{const char *}hex)
@deftypefnx {C function} @code{void} mgl_set_mask_val (@code{HMGL} gr, @code{uint64_t} hex)
@end ifclear
Sets new bit matrix @var{hex} of size 8*8 for mask with given @var{id}. This is global setting which influence on any later usage of symbol @var{id}. The predefined masks are (see @ref{Color scheme}): @samp{-} give lines (@code{0x000000FF00000000}), @samp{+} give cross-lines (@code{080808FF08080808}),	@samp{=} give double lines (@code{0000FF00FF000000}),	@samp{;} give dash lines (@code{0x0000000F00000000}), @samp{o} give circles (@code{0000182424180000}),	@samp{O} give filled circles (@code{0000183C3C180000}),	@samp{s} give squares (@code{00003C24243C0000}),	@samp{S} give solid squares (@code{00003C3C3C3C0000}), @samp{~} give waves (@code{0000060990600000}),	@samp{<} give left triangles (@code{0060584658600000}),	@samp{>} give right triangles (@code{00061A621A060000}),	@samp{j} give dash-dot lines (@code{0000002700000000}), @samp{d} give pluses (@code{0x0008083E08080000}),	@samp{D} give tacks (@code{0x0139010010931000}),	@samp{*} give dots (@code{0x0000001818000000}),	@samp{^} give bricks (@code{0x101010FF010101FF}). Parameter @var{angle} set the rotation angle too. IMPORTANT: the rotation angle will be replaced by a multiple of 45 degrees at export to EPS.
@end deftypefn

@deftypefn {MGL command} {} mask angle
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMaskAngle (@code{int} angle)
@deftypefnx {C function} @code{void} mgl_set_mask_angle (@code{HMGL} gr, @code{int} angle)
@end ifclear
Sets the default rotation angle (in degrees) for masks. Note, you can use symbols @samp{\}, @samp{/}, @samp{I} in color scheme for setting rotation angles as 45, -45 and 90 degrees correspondingly. IMPORTANT: the rotation angle will be replaced by a multiple of 45 degrees at export to EPS.
@end deftypefn


@c ==================================================================
@external{}
@node Error handling, Stop drawing, Masks, Graphics setup
@subsection Error handling
@nav{}
@ifset UDAV
All warnings will be displayed automatically in special tool-window or in console.
@end ifset
@ifclear UDAV
@cindex Message
@cindex SetWarn
@cindex GetWarn

Normally user should set it to zero by @code{SetWarn(0);} before plotting and check if @code{GetWarn()} or @code{Message()} return non zero after plotting. Only last warning will be saved. All warnings/errors produced by MathGL is not critical -- the plot just will not be drawn. By default, all warnings are printed in stderr. You can disable it by using @code{mgl_suppress_warn(true);}.

@deftypefn {Method on @code{mglGraph}} @code{void} SetWarn (@code{int} code, @code{const char *}info=@code{""})
@deftypefnx {C function} @code{void} mgl_set_warn (@code{HMGL} gr, @code{int} code, @code{const char *}info)
Set warning code. Normally you should call this function only for clearing the warning state, i.e. call @code{SetWarn(0);}. Text @var{info} will be printed as is if @var{code}<0.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{const char *}Message ()
@deftypefnx {C function only} @code{const char *}mgl_get_mess (@code{HMGL} gr)
@deftypefnx {Fortran subroutine} @code{} mgl_get_mess (@code{long} gr, @code{char *}out, @code{int} len)
Return messages about matters why some plot are not drawn. If returned string is empty then there are no messages.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetWarn ()
@deftypefnx {C function} @code{int} mgl_get_warn (@code{HMGL} gr)
Return the numerical ID of warning about the not drawn plot. Possible values are:
@table @code
@item mglWarnNone=0
Everything OK
@item mglWarnDim
Data dimension(s) is incompatible
@item mglWarnLow
Data dimension(s) is too small
@item mglWarnNeg
Minimal data value is negative
@item mglWarnFile
No file or wrong data dimensions
@item mglWarnMem
Not enough memory
@item mglWarnZero
Data values are zero
@item mglWarnLeg
No legend entries
@item mglWarnSlc
Slice value is out of range
@item mglWarnCnt
Number of contours is zero or negative
@item mglWarnOpen
Couldn't open file
@item mglWarnLId
Light: ID is out of range
@item mglWarnSize
Setsize: size(s) is zero or negative
@item mglWarnFmt
Format is not supported for that build
@item mglWarnTern
Axis ranges are incompatible
@item mglWarnNull
Pointer is NULL
@item mglWarnSpc
Not enough space for plot
@item mglScrArg
Wrong argument(s) of a command in MGL script
@item mglScrCmd
Wrong command in MGL script
@item mglScrLong
Too long line in MGL script
@item mglScrStr
Unbalanced ' in MGL script
@item mglScrTemp
Change temporary data in MGL script
@end table
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SuppressWarn (@code{bool} state) static
@deftypefnx {C function} @code{void} mgl_suppress_warn (@code{int} state)
Disable printing warnings to @code{stderr} if @var{state} is nonzero.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetGlobalWarn (@code{const char *}info) static
@deftypefnx {C function} @code{void} mgl_set_global_warn (@code{const char *}info)
Set warning message @var{info} for global scope.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{const char *} GlobalWarn () static
@deftypefnx {C function} @code{const char *} mgl_get_global_warn ()
Get warning message(s) for global scope.
@end deftypefn

@end ifclear

@c ==================================================================
@external{}
@node Stop drawing, , Error handling, Graphics setup
@subsection Stop drawing
@nav{}
@ifset UDAV
You can use @ref{stop} command or press corresponding toolbutton to stop drawing and script execution.
@end ifset
@ifclear UDAV
@cindex Stop
@cindex NeedStop
@cindex SetEventFunc

@deftypefn {Method on @code{mglGraph}} @code{void} Stop (@code{bool} stop=@code{true})
@deftypefnx {C function only} @code{void} mgl_ask_stop (@code{HMGL} gr, @code{int} stop)
Ask to stop drawing if @var{stop} is non-zero, otherwise reset stop flag.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{bool} NeedStop ()
@deftypefnx {C function only} @code{void} mgl_need_stop (@code{HMGL} gr)
Return @code{true} if drawing should be terminated. Also it process all events in GUI. User should call this function from time to time inside a long calculation to allow processing events for GUI.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{bool} SetEventFunc (@code{void (*}func@code{)(void *)}, @code{void *}par=@code{NULL})
@deftypefnx {C function only} @code{void} mgl_set_event_func (@code{HMGL} gr, @code{void (*}func@code{)(void *)}, @code{void *}par)
Set callback function which will be called to process events of GUI library.
@end deftypefn

@end ifclear

@c ==================================================================
@external{}
@node Axis settings, Subplots and rotation, Graphics setup, MathGL core
@section Axis settings
@nav{}

These large set of variables and functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (see @ref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box. Note, that MathGL will produce warning if axis range and transformation formulas are not compatible.

@menu
* Ranges (bounding box)::
* Curved coordinates::
* Ticks::
@end menu

@c ------------------------------------------------------------------
@external{}
@node Ranges (bounding box), Curved coordinates, , Axis settings
@subsection Ranges (bounding box)
@nav{}
@cindex CRange
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Ranges
@cindex Origin
@ifclear UDAV
@cindex SetRange
@cindex SetRanges
@cindex SetOrigin
@end ifclear

@anchor{xrange}
@anchor{yrange}
@anchor{zrange}
@anchor{crange}
@deftypefn {MGL command} {} xrange @code{v1 v2} [@code{add=off}]
@deftypefnx {MGL command} {} yrange @code{v1 v2} [@code{add=off}]
@deftypefnx {MGL command} {} zrange @code{v1 v2} [@code{add=off}]
@deftypefnx {MGL command} {} crange @code{v1 v2} [@code{add=off}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {Method on @code{mglGraph}} @code{void} AddRange (@code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {C function} @code{void} mgl_set_range_val (@code{HMGL} gr, @code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {C function} @code{void} mgl_add_range_val (@code{HMGL} gr, @code{char} dir, @code{mreal} v1, @code{mreal} v2)
@end ifclear
Sets or adds the range for @samp{x}-,@samp{y}-,@samp{z}- coordinate or coloring (@samp{c}). If one of values is @code{NAN} then it is ignored. See also @ref{ranges}.
@end deftypefn


@deftypefn {MGL command} {} xrange dat [@code{add=off}]
@deftypefnx {MGL command} {} yrange dat [@code{add=off}]
@deftypefnx {MGL command} {} zrange dat [@code{add=off}]
@deftypefnx {MGL command} {} crange dat [@code{add=off}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{const mglDataA &}dat, @code{bool} add=@code{false})
@deftypefnx {C function} @code{void} mgl_set_range_dat (@code{HMGL} gr, @code{char} dir, @code{const HCDT} a, @code{int} add)
@end ifclear
Sets the range for @samp{x}-,@samp{y}-,@samp{z}- coordinate or coloring (@samp{c}) as minimal and maximal values of data @var{dat}. Parameter @code{add=on} shows that the new range will be joined to existed one (not replace it).
@end deftypefn

@anchor{ranges}
@deftypefn {MGL command} {} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1=@code{0}, @code{double} z2=@code{0})
@deftypefnx {C function} @code{void} mgl_set_ranges (@code{HMGL} gr, @code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1, @code{double} z2)
@end ifclear
Sets the ranges of coordinates. If minimal and maximal values of the coordinate are the same then they are ignored. Also it sets the range for coloring (analogous to @code{crange z1 z2}). This is default color range for 2d plots. Initial ranges are [-1, 1].
@end deftypefn

@deftypefn {MGL command} {} ranges @code{xx yy [zz cc=zz]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy, @code{const mglDataA &}zz)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy, @code{const mglDataA &}zz, @code{const mglDataA &}cc)
@end ifclear
Sets the ranges of @samp{x}-,@samp{y}-,@samp{z}-,@samp{c}-coordinates and coloring as minimal and maximal values of data @var{xx}, @var{yy}, @var{zz}, @var{cc} correspondingly.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetAutoRanges (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAutoRanges (@code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1=@code{0}, @code{double} z2=@code{0}, @code{double} c1=@code{0}, @code{double} c2=@code{0})
@deftypefnx {C function} @code{void} mgl_set_auto_ranges (@code{HMGL} gr, @code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1, @code{double} z2, @code{double} z1, @code{double} z2)
Sets the ranges for automatic coordinates. If minimal and maximal values of the coordinate are the same then they are ignored.
@end deftypefn
@end ifclear

@anchor{origin}
@deftypefn {MGL command} {} origin @code{x0 y0 [z0=nan]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetOrigin (@code{mglPoint} p0)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetOrigin (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0=@code{NAN})
@deftypefnx {C function} @code{void} mgl_set_origin (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0)
@end ifclear
Sets center of axis cross section. If one of values is NAN then MathGL try to select optimal axis position.
@end deftypefn

@anchor{zoomaxis}
@deftypefn {MGL command} {} zoomaxis @code{x1 x2}
@deftypefnx {MGL command} {} zoomaxis @code{x1 y1 x2 y2}
@deftypefnx {MGL command} {} zoomaxis @code{x1 y1 z1 x2 y2 z2}
@deftypefnx {MGL command} {} zoomaxis @code{x1 y1 z1 c1 x2 y2 z2 c2}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ZoomAxis (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {C function} @code{void} mgl_zoom_axis (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} c1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} c2)
@end ifclear
Additionally extend axis range for any settings made by @code{SetRange} or @code{SetRanges} functions according the formula @math{min += (max-min)*p1} and @math{max += (max-min)*p1} (or @math{min *= (max/min)^p1} and @math{max *= (max/min)^p1} for log-axis range when @math{inf>max/min>100} or @math{0<max/min<0.01}). Initial ranges are [0, 1]. Attention! this settings can not be overwritten by any other functions, including @code{DefaultPlotParam()}.
@end deftypefn


@c ------------------------------------------------------------------
@external{}
@node Curved coordinates, Ticks, Ranges (bounding box), Axis settings
@subsection Curved coordinates
@nav{}
@cindex Axis
@ifclear UDAV
@cindex SetFunc
@cindex SetCoor
@cindex Ternary
@end ifclear

@deftypefn {MGL command} {} axis 'fx' 'fy' 'fz' ['fa'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetFunc (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ=@code{""}, @code{const char *}EqA=@code{""})
@deftypefnx {C function} @code{void} mgl_set_func (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ, @code{const char *}EqA)
@end ifclear
Sets transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates @samp{x}, @samp{y}, @samp{z} and @samp{a} or @samp{c} for colorbar. For example, the cylindrical coordinates are introduced as @code{SetFunc("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be empty or @code{NULL}. Using transformation formulas will slightly slowing the program. Parameter @var{EqA} set the similar transformation formula for color scheme. @xref{Textual formulas}.
@end deftypefn

@deftypefn {MGL command} {} axis @code{how}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCoor (@code{int} how)
@deftypefnx {C function} @code{void} mgl_set_coor (@code{HMGL} gr, @code{int} how)
@end ifclear
Sets one of the predefined transformation formulas for curvilinear coordinate. Parameter @var{how} define the coordinates:
@table @code
@item mglCartesian=0
Cartesian coordinates (no transformation, @{x,y,z@});
@item mglPolar=1
Polar coordinates: @{x*cos(y), x*sin(y), z@};
@item mglSpherical=2
Sperical coordinates: @{x*sin(y)*cos(z), x*sin(y)*sin(z), x*cos(y)@};
@item mglParabolic=3
Parabolic coordinates: @{x*y, (x*x-y*y)/2, z@}
@item mglParaboloidal=4
Paraboloidal coordinates: @{(x*x-y*y)*cos(z)/2, (x*x-y*y)*sin(z)/2, x*y@};
@item mglOblate=5
Oblate coordinates: @{cosh(x)*cos(y)*cos(z), cosh(x)*cos(y)*sin(z), sinh(x)*sin(y)@};
@item mglProlate=6
Prolate coordinates: @{sinh(x)*sin(y)*cos(z), sinh(x)*sin(y)*sin(z), cosh(x)*cos(y)@};
@item mglElliptic=7
Elliptic coordinates: @{cosh(x)*cos(y), sinh(x)*sin(y), z@};
@item mglToroidal=8
Toroidal coordinates: @{sinh(x)*cos(z)/(cosh(x)-cos(y)), sinh(x)*sin(z)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y))@};
@item mglBispherical=9
Bispherical coordinates: @{sin(y)*cos(z)/(cosh(x)-cos(y)), sin(y)*sin(z)/(cosh(x)-cos(y)), sinh(x)/(cosh(x)-cos(y))@};
@item mglBipolar=10
Bipolar coordinates: @{sinh(x)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y)), z@};
@item mglLogLog=11
Log-log coordinates: @{lg(x), lg(y), lg(z)@};
@item mglLogX=12
Log-x coordinates: @{lg(x), y, z@};
@item mglLogY=13
Log-y coordinates: @{x, lg(y), z@}.
@end table
@end deftypefn

@anchor{ternary}
@deftypefn {MGL command} {} ternary @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ternary (@code{int} tern)
@deftypefnx {C function} @code{void} mgl_set_ternary (@code{HMGL} gr, @code{int} tern)
@end ifclear
The function sets to draws Ternary (@var{tern}=@code{1}), Quaternary (@var{tern}=@code{2}) plot or projections (@var{tern}=@code{4,5,6}).

Ternary plot is special plot for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on.

Correspondingly, Quaternary plot is plot for 4 dependent coordinates @var{a}, @var{b}, @var{c} and @var{d} so that @var{a}+@var{b}+@var{c}+@var{d}=1. MathGL uses only 3 independent coordinates @var{a}=x, @var{b}=y and @var{d}=z since it is enough to plot everything.

Projections can be obtained by adding value @code{4} to @var{tern} argument. So, that @var{tern}=@code{4} will draw projections in Cartesian coordinates, @var{tern}=@code{5} will draw projections in Ternary coordinates, @var{tern}=@code{6} will draw projections in Quaternary coordinates. If you add @code{8} instead of @code{4} then all text labels will not be printed  on projections.

Use @code{Ternary(0)} for returning to usual axis. @sref{Ternary axis} @sref{Axis projection}
@end deftypefn

@c ------------------------------------------------------------------
@external{}
@node Ticks, , Curved coordinates, Axis settings
@subsection Ticks
@nav{}
@cindex AxisStl
@cindex TickLen
@cindex Adjust
@cindex XTick
@cindex YTick
@cindex ZTick
@cindex CTick
@ifclear UDAV
@cindex SetAxisStl
@cindex SetTickLen
@cindex SetTicks
@cindex SetTicksVal
@cindex SetTuneTicks
@cindex SetTickTime
@cindex SetTickTempl
@cindex SetTickRotate
@cindex SetTickSkip
@cindex SetOriginTick
@cindex AddTick
@end ifclear

@anchor{adjust}
@deftypefn {MGL command} {} adjust ['dir'='xyzc']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Adjust (@code{const char *}dir=@code{"xyzc"})
@deftypefnx {C function} @code{void} mgl_adjust_ticks (@code{HMGL} gr, @code{const char *}dir)
@end ifclear
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @code{SetTuneTicks(true)}. Usually you don't need to call this function except the case of returning to default settings.
@end deftypefn

@anchor{xtick}
@anchor{ytick}
@anchor{ztick}
@anchor{ctick}
@deftypefn {MGL command} {} xtick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {MGL command} {} ytick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {MGL command} {} ztick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {MGL command} {} xtick @code{val sub ['fact'='']}
@deftypefnx {MGL command} {} ytick @code{val sub ['fact'='']}
@deftypefnx {MGL command} {} ztick @code{val sub ['fact'='']}
@deftypefnx {MGL command} {} ctick @code{val ['fact'='']}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicks (@code{char} dir, @code{mreal} d=@code{0}, @code{int} ns=@code{0}, @code{mreal} org=@code{NAN}, @code{const char *}fact=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicks (@code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org, @code{const wchar_t *}fact)
@deftypefnx {C function} @code{void} mgl_set_ticks (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org)
@deftypefnx {C function} @code{void} mgl_set_ticks_fact (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org, @code{const char *}fact)
@deftypefnx {C function} @code{void} mgl_set_ticks_factw (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org, @code{const wchar_t *}fact)
@end ifclear
Set the ticks step @var{d}, number of sub-ticks @var{ns} (used for positive @var{d}) and initial ticks position @var{org} for the axis along direction @var{dir} (use 'c' for colorbar ticks). Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set automatic ticks. If @var{org} value is NAN then axis origin is used. Parameter @var{fact} set text which will be printed after tick label (like "\pi" for @var{d}=M_PI).
@end deftypefn

@deftypefn {MGL command} {} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} ctick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} xtick vdat 'lbls' [@code{add=off}]
@deftypefnx {MGL command} {} ytick vdat 'lbls' [@code{add=off}]
@deftypefnx {MGL command} {} ztick vdat 'lbls' [@code{add=off}]
@deftypefnx {MGL command} {} ctick vdat 'lbls' [@code{add=off}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglDataA &}val, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglDataA &}val, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {C function} @code{void} mgl_set_ticks_str (@code{HMGL} gr, @code{char} dir, @code{const char *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_wcs (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_val (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const char *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_valw (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const wchar_t *}lbl, @code{bool} add)
@end ifclear
Set the manual positions @var{val} and its labels @var{lbl} for ticks along axis @var{dir}. If array @var{val} is absent then values equidistantly distributed in x-axis range are used. Labels are separated by @samp{\n} symbol. If only one value is specified in MGL command then the label will be @emph{add} to the current ones. Use @code{SetTicks()} to restore automatic ticks.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} AddTick (@code{char} dir, @code{double} val, @code{const char *}lbl)
@deftypefnx {Method on @code{mglGraph}} @code{void} AddTick (@code{char} dir, @code{double} val, @code{const wchar_t *}lbl)
@deftypefnx {C function} @code{void} mgl_add_tick (@code{HMGL} gr, @code{char} dir, @code{double} val, @code{const char *}lbl)
@deftypefnx {C function} @code{void} mgl_set_tickw (@code{HMGL} gr, @code{char} dir, @code{double} val, @code{const wchar_t *}lbl)
The same as previous but add single tick label @var{lbl} at position @var{val} to the list of existed ones.
@end deftypefn
@end ifclear

@deftypefn {MGL command} {} xtick 'templ'
@deftypefnx {MGL command} {} ytick 'templ'
@deftypefnx {MGL command} {} ztick 'templ'
@deftypefnx {MGL command} {} ctick 'templ'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const char *}templ)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_tick_templ (@code{HMGL} gr, @code{const char *}templ)
@deftypefnx {C function} @code{void} mgl_set_tick_templw (@code{HMGL} gr, @code{const wchar_t *}templ)
@end ifclear
Set template @var{templ} for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{templ}=@code{""} then default template is used (in simplest case it is @samp{%.2g}). If template start with @samp{&} symbol then @code{long} integer value will be passed instead of default type @code{double}. Setting on template switch off automatic ticks tuning.
@end deftypefn

@anchor{ticktime}
@deftypefn {MGL command} {} ticktime 'dir' [@code{dv=0} 'tmpl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksTime (@code{char} dir, @code{mreal} val, @code{const char *}templ)
@deftypefnx {C function} @code{void} mgl_set_ticks_time (@code{HMGL} gr, @code{mreal} val, @code{const char *}templ)
@end ifclear
Sets time labels with step @var{val} and template @var{templ} for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. The format of template @var{templ} is the same as described in @url{http://www.manpagez.com/man/3/strftime/}. Most common variants are @samp{%X} for national representation of time, @samp{%x} for national representation of date, @samp{%Y} for year with century. If @var{val}=0 and/or @var{templ}="" then automatic tick step and/or template will be selected. You can use @code{mgl_get_time}() function for obtaining number of second for given date/time string. Note, that MS Visual Studio couldn't handle date before 1970.
@end deftypefn

@ifclear UDAV
@deftypefn {C function} @code{double} mgl_get_time (@code{const char*}str, @code{const char *}templ)
Gets number of seconds from 1970 year to specified date/time @var{str}. The format of string is specified by @var{templ}, which is the same as described in @url{http://www.manpagez.com/man/3/strftime/}. Most common variants are @samp{%X} for national representation of time, @samp{%x} for national representation of date, @samp{%Y} for year with century. Note, that MS Visual Studio couldn't handle date before 1970.
@end deftypefn
@end ifclear

@anchor{tuneticks}
@deftypefn {MGL command} {} tuneticks @code{val} [@code{pos=1.15}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTuneTicks (@code{int} tune, @code{mreal} pos=@code{1.15})
@deftypefnx {C function} @code{void} mgl_tune_ticks (@code{HMGL} gr, @code{int} tune, @code{mreal} pos)
@end ifclear
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values -- enabled if @var{tune}&1 is nonzero) or common component (for narrow range, like from 0.999 to 1.000 -- enabled if @var{tune}&2 is nonzero). Also set the position @var{pos} of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypefn

@anchor{tickshift}
@deftypefn {MGL command} {} tickshift @code{dx [dy=0 dz=0 dc=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickShift (@code{mglPoint} d)
@deftypefnx {C function} @code{void} mgl_set_tick_shift (@code{HMGL} gr, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{mreal} dc)
@end ifclear
Set value of additional shift for ticks labels.
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} SetTickRotate (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_tick_rotate (@code{HMGL} gr, @code{bool} val)
Enable/disable ticks rotation if there are too many ticks or ticks labels are too long.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetTickSkip (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_tick_skip (@code{HMGL} gr, @code{bool} val)
Enable/disable ticks skipping if there are too many ticks or ticks labels are too long.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetTimeUTC (@code{bool} val)
@c @deftypefnx {C function} @code{void} mgl_set_tick_skip (@code{HMGL} gr, @code{bool} val)
Enable/disable using UTC time for ticks labels. In C/Fortran you can use @code{mgl_set_flag(gr,val, MGL_USE_GMTIME);}.
@end deftypefn

@end ifclear

@anchor{origintick}
@deftypefn {MGL command} {} origintick @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetOriginTick (@code{bool} val=@code{true})
@end ifclear
Enable/disable drawing of ticks labels at axis origin. In C/Fortran you can use @code{mgl_set_flag(gr,val, MGL_NO_ORIGIN);}.
@end deftypefn

@anchor{ticklen}
@deftypefn {MGL command} {} ticklen @code{val} [@code{stt=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickLen (@code{mreal} val, @code{mreal} stt=@code{1})
@deftypefnx {C function} @code{void} mgl_set_tick_len (@code{HMGL} gr, @code{mreal} val, @code{mreal} stt)
@end ifclear
The relative length of axis ticks. Default value is @code{0.1}. Parameter @var{stt}>0 set relative length of subticks which is in @code{sqrt(1+stt)} times smaller.
@end deftypefn

@deftypefn {MGL command} {} axisstl 'stl' ['tck'='' 'sub'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAxisStl (@code{const char *}stl=@code{"k"}, @code{const char *}tck=@code{0}, @code{const char *}sub=@code{0})
@deftypefnx {C function} @code{void} mgl_set_axis_stl (@code{HMGL} gr, @code{const char *}stl, @code{const char *}tck, @code{const char *}sub)
@end ifclear
The line style of axis (@var{stl}), ticks (@var{tck}) and subticks (@var{sub}). If @var{stl} is empty then default style is used (@samp{k} or @samp{w} depending on transparency type). If @var{tck} or @var{sub} is empty then axis style is used (i.e. @var{stl}).
@end deftypefn

@c ##################################################################
@external{}
@node Subplots and rotation, Export picture, Axis settings, MathGL core
@section Subplots and rotation
@nav{}
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex MultiPlot
@cindex StickPlot
@cindex ColumnPlot
@cindex InPlot
@cindex Title
@cindex Perspective
@cindex View
@cindex Push
@cindex Pop

These functions control how and where further plotting will be placed. There is a certain calling order of these functions for the better plot appearance. First one should be @ref{subplot}, @ref{multiplot} or @ref{inplot} for specifying the place. Second one can be @ref{title} for adding title for the subplot. After it a @ref{rotate}, @ref{shear} and @ref{aspect}. And finally any other plotting functions may be called. Alternatively you can use @ref{columnplot}, @ref{gridplot}, @ref{stickplot}, @ref{shearplot} or relative @ref{inplot} for positioning plots in the column (or grid, or stick) one by another without gap between plot axis (bounding boxes). @sref{Subplots}

@anchor{subplot}
@deftypefn {MGL command} {} subplot @code{nx ny m} ['stl'='<>_^' @code{dx=0 dy=0}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl=@code{"<>_^"}, @code{mreal} dx=@code{0}, @code{mreal} dy=@code{0})
@deftypefnx {C function} @code{void} mgl_subplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl)
@deftypefnx {C function} @code{void} mgl_subplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl, @code{mreal} dx, @code{mreal} dy)
@end ifclear
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}. This function set off any aspects or rotations. So it should be used first for creating the subplot. Extra space will be reserved for axis/colorbar if @var{stl} contain:
@itemize @bullet
@item
@samp{L} or @samp{<} -- at left side,
@item
@samp{R} or @samp{>} -- at right side,
@item
@samp{A} or @samp{^} -- at top side,
@item
@samp{U} or @samp{_} -- at bottom side,
@item
@samp{#} -- reserve none space (use whole region for axis range) -- axis and tick labels will be invisible by default.
@end itemize
From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. Note, colorbar can be invisible (be out of image borders) if you set empty style @samp{}.
@end deftypefn

@anchor{multiplot}
@deftypefn {MGL command} {} multiplot @code{nx ny m dx dy} ['style'='<>_^' sx sy]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} MultiPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl=@code{"<>_^"})
@deftypefnx {C function} @code{void} mgl_multiplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl)
@end ifclear
Puts further plotting in a rectangle of @var{dx}*@var{dy} cells starting from @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. The position of the rectangular area can be shifted from its default position by relative size @var{sx}, @var{sy}. This function set off any aspects or rotations.  So it should be used first for creating subplot. Extra space will be reserved for axis/colorbar if @var{stl} contain:
@itemize @bullet
@item
@samp{L} or @samp{<} -- at left side,
@item
@samp{R} or @samp{>} -- at right side,
@item
@samp{A} or @samp{^} -- at top side,
@item
@samp{U} or @samp{_} -- at bottom side.
@samp{#} -- reserve none space (use whole region for axis range) -- axis and tick labels will be invisible by default.
@end itemize
@end deftypefn

@anchor{inplot}
@deftypefn {MGL command} {} inplot @code{x1 x2 y1 y2 [rel=on]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} InPlot (@code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2, @code{bool} rel=@code{true})
@deftypefnx {C function} @code{void} mgl_inplot (@code{HMGL} gr, @code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2)
@deftypefnx {C function} @code{void} mgl_relplot (@code{HMGL} gr, @code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2)
@end ifclear
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{true} then the relative position to current @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}) is used. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypefn

@anchor{columnplot}
@deftypefn {MGL command} {} columnplot @code{num ind [d=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ColumnPlot (@code{int} num, @code{int} ind, @code{mreal} d=@code{0})
@deftypefnx {C function} @code{void} mgl_columnplot (@code{HMGL} gr, @code{int} num, @code{int} ind)
@deftypefnx {C function} @code{void} mgl_columnplot_d (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} d)
@end ifclear
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}). Parameter @var{d} set extra gap between cells.
@end deftypefn

@anchor{gridplot}
@deftypefn {MGL command} {} gridplot @code{nx ny ind [d=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} GridPlot (@code{int} nx, @code{int} ny, @code{int} ind, @code{mreal} d=@code{0})
@deftypefnx {C function} @code{void} mgl_gridplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind)
@deftypefnx {C function} @code{void} mgl_gridplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind, @code{mreal} d)
@end ifclear
Puts further plotting in @var{ind}-th cell of @var{nx}*@var{ny} grid. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}). Parameter @var{d} set extra gap between cells.
@end deftypefn

@anchor{stickplot}
@deftypefn {MGL command} {} stickplot @code{num ind tet phi}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} StickPlot (@code{int} num, @code{int} ind, @code{mreal} tet, @code{mreal} phi)
@deftypefnx {C function} @code{void} mgl_stickplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} tet, @code{mreal} phi)
@end ifclear
Puts further plotting in @var{ind}-th cell of stick with @var{num} cells. At this, stick is rotated on angles @var{tet}, @var{phi}. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}).
@end deftypefn

@anchor{shearplot}
@deftypefn {MGL command} {} shearplot @code{num ind sx sy [xd yd]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ShearPlot (@code{int} num, @code{int} ind, @code{mreal} sx, @code{mreal} sy, @code{mreal} xd=@code{1}, @code{mreal} yd=@code{0})
@deftypefnx {C function} @code{void} mgl_shearplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} sx, @code{mreal} sy, @code{mreal} xd, @code{mreal} yd)
@end ifclear
Puts further plotting in @var{ind}-th cell of stick with @var{num} cells. At this, cell is sheared on values @var{sx}, @var{sy}. Stick direction is specified be @var{xd} and @var{yd}. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}).
@end deftypefn


@anchor{title}
@deftypefn {MGL command} {} title 'title' ['stl'='' @code{size=-2}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Title (@code{const char *}txt, @code{const char *}stl=@code{""}, @code{mreal} size=@code{-2})
@deftypefnx {Method on @code{mglGraph}} @code{void} Title (@code{const wchar_t *}txt, @code{const char *}stl=@code{""}, @code{mreal} size=@code{-2})
@deftypefnx {C function} @code{void} mgl_title (@code{HMGL} gr, @code{const char *}txt, @code{const char *}stl, @code{mreal} size)
@deftypefnx {C function} @code{void} mgl_titlew (@code{HMGL} gr, @code{const wchar_t *}txt, @code{const char *}stl, @code{mreal} size)
@end ifclear
Add text @var{title} for current subplot/inplot. Parameter @var{stl} can contain:
@itemize @bullet
@item
font style (see, @ref{Font styles});
@item
@samp{#} for box around the title.
@end itemize
Parameter @var{size} set font size. This function set off any aspects or rotations. So it should be used just after creating subplot.
@end deftypefn

@anchor{rotate}
@deftypefn {MGL command} {} rotate @code{tetx tetz [tety=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Rotate (@code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY=@code{0})
@deftypefnx {C function} @code{void} mgl_rotate (@code{HMGL} gr, @code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY)
@end ifclear
Rotates a further plotting relative to each axis @{x, z, y@} consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypefn

@deftypefn {MGL command} {} rotate @code{tet x y z}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} RotateN (@code{mreal} Tet, @code{mreal} x, @code{mreal} y, @code{mreal} z)
@deftypefnx {C function} @code{void} mgl_rotate_vector (@code{HMGL} gr, @code{mreal Tet}, @code{mreal x}, @code{mreal y}, @code{mreal z})
@end ifclear
Rotates a further plotting around vector @{@var{x}, @var{y}, @var{z}@} on angle @var{Tet}.
@end deftypefn

@anchor{shear}
@deftypefn {MGL command} {} shear @code{sx sy}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Shear (@code{mreal} sx, @code{mreal} sy)
@deftypefnx {C function} @code{void} mgl_shear (@code{HMGL} gr, @code{mreal} sx, @code{mreal} sy)
@end ifclear
Shears a further plotting on values @var{sx}, @var{sy}.
@end deftypefn

@anchor{aspect}
@deftypefn {MGL command} {} aspect @code{ax ay [az=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Aspect (@code{mreal} Ax, @code{mreal} Ay, @code{mreal} Az=@code{1})
@deftypefnx {C function} @code{void} mgl_aspect (@code{HMGL} gr, @code{mreal} Ax, @code{mreal} Ay, @code{mreal} Az)
@end ifclear
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after @ref{rotate} function. If @var{Ax} is @code{NAN} then function try to select optimal aspect ratio to keep equal ranges for x-y axis. At this, @var{Ay} will specify proportionality factor, or set to use automatic one if @var{Ay}=@code{NAN}.
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} Push ()
@deftypefnx {C function} @code{void} mgl_mat_push (@code{HMGL} gr)
Push transformation matrix into stack. Later you can restore its current state by Pop() function.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} Pop ()
@deftypefnx {C function} @code{void} mgl_mat_pop (@code{HMGL} gr)
Pop (restore last 'pushed') transformation matrix into stack.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetPlotFactor (@code{mreal} val)
@deftypefnx {C function} @code{void} mgl_set_plotfactor (@code{HMGL} gr, @code{mreal} val)
Sets the factor of plot size. It is not recommended to set it lower then 1.5. This is some analogue of function Zoom() but applied not to overall image but for each InPlot. Use negative value or zero to enable automatic selection.
@end deftypefn

@end ifclear

There are 3 functions @code{View()}, @code{Zoom()} and @code{Perspective()} which transform whole image. I.e. they act as secondary transformation matrix. They were introduced for rotating/zooming the whole plot by mouse. It is not recommended to call them for picture drawing.

@anchor{perspective}
@deftypefn {MGL command} {} perspective @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Perspective (@code{mreal} a)
@deftypefnx {C function} @code{void} mgl_perspective (@code{HMGL} gr, @code{mreal} a)
@end ifclear
Add (switch on) the perspective to plot. The parameter @math{a = Depth/(Depth+dz) \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypefn

@anchor{view}
@deftypefn {MGL command} {} view @code{tetx tetz [tety=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} View (@code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY=@code{0})
@deftypefnx {C function} @code{void} mgl_view (@code{HMGL} gr, @code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY)
@end ifclear
Rotates a further plotting relative to each axis @{x, z, y@} consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}. Rotation is done independently on @ref{rotate}. Attention! this settings can not be overwritten by @code{DefaultPlotParam()}. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@anchor{zoom}
@deftypefn {MGL command} {} zoom @code{x1 y1 x2 y2}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Zoom (@code{mreal} x1, @code{mreal} y1, @code{mreal} x2, @code{mreal} y2)
@deftypefnx {C function} @code{void} mgl_set_zoom (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} x2, @code{mreal} y2)
@end ifclear
The function changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions, including @code{DefaultPlotParam()}. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@c ##################################################################
@external{}
@node Export picture, Background, Subplots and rotation, MathGL core
@section Export picture
@nav{}
@cindex SetSize

Functions in this group save or give access to produced picture. So, usually they should be called after plotting is done.

@anchor{setsize}
@deftypefn {MGL command} {} setsize @code{w h}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetSize (@code{int} width, @code{int} height, @code{bool} clear=@code{true})
@deftypefnx {C function} @code{void} mgl_set_size (@code{HMGL} gr, @code{int} width, @code{int} height)
@deftypefnx {C function} @code{void} mgl_scale_size (@code{HMGL} gr, @code{int} width, @code{int} height)
@end ifclear
Sets size of picture in pixels. This function @strong{should be} called before any other plotting because it completely remove picture contents if @var{clear}=@code{true}. Function just clear pixels and scale all primitives if @var{clear}=@code{false}.
@end deftypefn

@anchor{setsizescl}
@deftypefn {MGL command} {} setsizescl @code{factor}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetSizeScl (@code{double} factor)
@deftypefnx {C function} @code{void} mgl_set_size_scl (@code{HMGL} gr, @code{double} factor)
@end ifclear
Set factor for width and height in all further calls of @ref{setsize}. This command is @strong{obsolete} since v.2.4.2.
@end deftypefn

@anchor{quality}
@deftypefn {MGL command} {} quality [@code{val}=2]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetQuality (@code{int} val=@code{MGL_DRAW_NORM})
@deftypefnx {C function} @code{void} mgl_set_quality (@code{HMGL} gr, @code{int} val)
@end ifclear
Sets quality of the plot depending on value @var{val}: @code{MGL_DRAW_WIRE=0} -- no face drawing (fastest), @code{MGL_DRAW_FAST=1} -- no color interpolation (fast), @code{MGL_DRAW_NORM=2} -- high quality (normal), @code{MGL_DRAW_HIGH=3} -- high quality with 3d primitives (arrows and marks); @code{MGL_DRAW_LMEM=0x4} -- direct bitmap drawing (low memory usage); @code{MGL_DRAW_DOTS=0x8} -- for dots drawing instead of primitives (extremely fast).
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{int} GetQuality ()
@deftypefnx {C function} @code{int} mgl_get_quality (@code{HMGL} gr)
Gets quality of the plot: @code{MGL_DRAW_WIRE=0} -- no face drawing (fastest), @code{MGL_DRAW_FAST=1} -- no color interpolation (fast), @code{MGL_DRAW_NORM=2} -- high quality (normal), @code{MGL_DRAW_HIGH=3} -- high quality with 3d primitives (arrows and marks); @code{MGL_DRAW_LMEM=0x4} -- direct bitmap drawing (low memory usage); @code{MGL_DRAW_DOTS=0x8} -- for dots drawing instead of primitives (extremely fast).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} StartGroup (const char *name)
@deftypefnx {C function} @code{void} mgl_start_group (@code{HMGL} gr, @code{const char *}name)
Starts group definition. Groups contain objects and other groups, they are used to select a part of a model to zoom to or to make invisible or to make semitransparent and so on.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} EndGroup ()
@deftypefnx {C function} @code{void} mgl_end_group (@code{HMGL} gr)
Ends group definition.
@end deftypefn
@end ifclear

@menu
* Export to file::
* Frames/Animation::
* Bitmap in memory::
* Parallelization::
@end menu

@c ==================================================================
@external{}
@node Export to file, Frames/Animation, , Export picture
@subsection Export to file
@nav{}
@cindex Write
@ifclear UDAV
@cindex WriteFrame
@cindex WritePNG
@cindex WriteGIF
@c @cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteBPS
@cindex WriteTGA
@cindex WriteTEX
@cindex WritePRC
@cindex WriteOBJ
@cindex WriteWGL
@cindex WriteJPEG
@cindex ShowImage
@end ifclear

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG, SVG, OBJ and PRC files.

@anchor{write}
@deftypefn {MGL command} {} write ['fname'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} WriteFrame (@code{const char *}fname=@code{""}, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_frame (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@end ifclear
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{""}). If @var{fname}=@code{""} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id and name @samp{frame} is defined by @ref{plotid} class property.
@end deftypefn

@anchor{bbox}
@deftypefn {MGL command} {} bbox x1 y1 [x2=@code{-1} y2=@code{-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetBBox (@code{int} x1=@code{0}, @code{int} y1=@code{0}, @code{int} x2=@code{-1}, @code{int} y2=@code{-1})
@deftypefnx {C function} @code{void} mgl_set_bbox (@code{HMGL} gr, @code{int} x1, @code{int} y1, @code{int} x2, @code{int} y2)
@end ifclear
Set boundary box for export graphics into 2D file formats. If @var{x2}<0 (@var{y2}<0) then original image width (height) will be used. If @var{x1}<0 or @var{y1}<0 or @var{x1}>=@var{x2}|Width or @var{y1}>=@var{y2}|Height then cropping will be disabled.
@end deftypefn


@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{int} compr=@code{""}, @code{bool} alpha=@code{true})
@deftypefnx {C function} @code{void} mgl_write_png (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@deftypefnx {C function} @code{void} mgl_write_png_solid (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to PNG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file, @var{alpha} gives the transparency type. By default there are no description added and semitransparent image used. This function does nothing if HAVE_PNG isn't defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_jpg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if HAVE_JPEG isn't defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_gif (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to GIF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if HAVE_GIF isn't defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_bmp (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteTGA (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_tga (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to TGA file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file using vector representation. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. If file name is terminated by @samp{z} (for example, @samp{fname.eps.gz}) then file will be compressed in gzip format. Note, that EPS format don't support color interpolation, and the resulting plot will look as you use @ref{quality}=1 for plotting.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteBPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file using bitmap representation. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. If file name is terminated by @samp{z} (for example, @samp{fname.eps.gz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_svg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to SVG (Scalable Vector Graphics) file using vector representation. In difference of EPS format, SVG format support transparency that allows to correctly draw semitransparent plot (like @ref{surfa}, @ref{surf3a} or @ref{cloud}). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name). If file name is terminated by @samp{z} (for example, @samp{fname.svgz}) then file will be compressed in gzip format. Note, that SVG format don't support color interpolation, and the resulting plot will look as you use @ref{quality}=1 for plotting.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteTEX (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_tex (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to LaTeX (package Tikz/PGF) file using vector representation. Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name). Note, there is no text scaling now (for example, in subplots), what may produce miss-aligned labels.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WritePRC (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{bool} make_pdf=@code{true})
@deftypefnx {C function} @code{void} mgl_write_prc (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr, @code{int} make_pdf)
Exports current frame to PRC file using vector representation (see @url{http://en.wikipedia.org/wiki/PRC_%28file_format%29}). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name). If parameter @var{make_pdf}=@code{true} and PDF was enabled at MathGL configure then corresponding PDF file with 3D image will be created.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteOBJ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to OBJ/MTL file using vector representation (see @url{http://en.wikipedia.org/wiki/Wavefront_.obj_file, OBJ format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteXYZ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_xyz (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to XYZ/XYZL/XYZF files using vector representation (see @url{http://people.sc.fsu.edu/~jburkardt/data/xyz/xyz.html, XYZ format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteSTL (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_stl (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to STL file using vector representation (see @url{http://en.wikipedia.org/wiki/STL_(file_format), STL format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteOFF (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{bool} colored=@code{false})
@deftypefnx {C function} @code{void} mgl_write_off (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr, @code{bool} colored)
Exports current frame to OFF file using vector representation (see @url{http://people.sc.fsu.edu/~jburkardt/data/off/off.html, OFF format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@c @deftypefn {Method on @code{mglGraph}} @code{void} WriteX3D (@code{const char *}fname, @code{const char *}descr=@code{""})
@c @deftypefnx {C function} @code{void} mgl_write_x3d (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@c Exports current frame to X3D file using vector representation (see @url{http://en.wikipedia.org/wiki/X3d, X3D format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@c @end deftypefn


@c @deftypefn {Method on @code{mglGraph}} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{""})
@c @deftypefnx {C function} @code{void} mgl_write_idtf (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@c Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@c @end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ShowImage (@code{const char *}viewer, @code{bool} nowait=@code{false})
@deftypefnx {C function} @code{void} mgl_show_image (@code{const char *}viewer, @code{int} nowait)
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{void} WriteJSON (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_json (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to textual file using @ref{JSON format}. Later this file can be used for faster loading and viewing by JavaScript script. Parameter @var{fname} specifies the file name, @var{descr} adds description to file.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ExportMGLD (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_export_mgld (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports points and primitives in file using @ref{MGLD format}. Later this file can be used for faster loading and viewing by @code{mglview} utility. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ImportMGLD (@code{const char *}fname, @code{bool} add=@code{false})
@deftypefnx {C function} @code{void} mgl_import_mgld (@code{HMGL} gr, @code{const char *}fname, @code{int} add)
Imports points and primitives in file using @ref{MGLD format}. Later this file can be used for faster loading and viewing by @code{mglview} utility. Parameter @var{fname} specifies the file name, @var{add} sets to append or replace primitives to existed ones.
@end deftypefn

@end ifclear


@c ##################################################################
@external{}
@node Frames/Animation, Bitmap in memory, Export to file, Export picture
@subsection Frames/Animation
@nav{}

@ifset UDAV
There are no commands for making animation in MGL. However you can use features of @code{mglconv} and @code{mglview} utilities. For example, by busing special comments @samp{##a } or @samp{##c }.
@end ifset

@ifclear UDAV
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame
@cindex ResetFrames
@cindex StartGIF
@cindex CloseGIF

These functions provide ability to create several pictures simultaneously. For most of cases it is useless but for widget classes (see @ref{Widget classes}) they can provide a way to show animation. Also you can write several frames into animated GIF file.

@deftypefn {Method on @code{mglGraph}} @code{void} NewFrame ()
@deftypefnx {C function} @code{void} mgl_new_frame (@code{HMGL} gr)
Creates new frame. Function returns current frame id. This is not thread safe function in OpenGL mode! Use direct list creation in multi-threading drawing. The function @code{EndFrame()} @strong{must} be call after the finishing of the frame drawing for each call of this function.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} EndFrame ()
@deftypefnx {C function} @code{void} mgl_end_frame (@code{HMGL} gr)
Finishes the frame drawing.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetNumFrame ()
@deftypefnx {C function} @code{int} mgl_get_num_frame (@code{HMGL} gr)
Gets the number of created frames.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetFrame (@code{int} i)
@deftypefnx {C function} @code{void} mgl_set_frame (@code{HMGL} gr, @code{int} i)
Finishes the frame drawing and sets drawing data to frame @var{i}, which should be in range [0, @code{GetNumFrame()}-1]. This function is similar to @code{EndFrame()} but don't add frame to the GIF image.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} GetFrame (@code{int} i)
@deftypefnx {C function} @code{void} mgl_get_frame (@code{HMGL} gr, @code{int} i)
Replaces drawing data by one from frame @var{i}. Function work if @code{MGL_VECT_FRAME} is set on (by default).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ShowFrame (@code{int} i)
@deftypefnx {C function} @code{void} mgl_show_frame (@code{HMGL} gr, @code{int} i)
Appends drawing data from frame @var{i} to current one. Function work if @code{MGL_VECT_FRAME} is set on (by default).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} DelFrame (@code{int} i)
@deftypefnx {C function} @code{void} mgl_del_frame (@code{HMGL} gr, @code{int} i)
Deletes drawing data for frame @var{i} and shift all later frame indexes. Function work if @code{MGL_VECT_FRAME} is set on (by default). Do nothing in OpenGL mode.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ResetFrames ()
@deftypefnx {C function} @code{void} mgl_reset_frames (@code{HMGL} gr)
Reset frames counter (start it from zero).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ClearFrame (@code{int} i)
@deftypefnx {C function} @code{void} mgl_clear_frame (@code{HMGL} gr, @code{int} i)
Clear list of primitives for current drawing.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
@deftypefnx {C function} @code{void} mgl_start_gif (@code{HMGL} gr, @code{const char *}fname, @code{int} ms)
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use @code{CloseGIF()} to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} CloseGIF ()
@deftypefnx {C function} @code{void} mgl_close_gif (@code{HMGL} gr)
Finish writing animated GIF and close connected pointers.
@end deftypefn
@end ifclear

@c ------------------------------------------------------------------
@external{}
@node Bitmap in memory, Parallelization, Frames/Animation, Export picture
@subsection Bitmap in memory
@nav{}

@ifclear UDAV
These functions return the created picture (bitmap), its width and height. You may display it by yourself in any graphical library (see also, @ref{Widget classes}) or save in file (see also, @ref{Export to file}).

@deftypefn {Method on @code{mglGraph}} @code{const unsigned char *} GetRGB ()
@deftypefnx {Method on @code{mglGraph}} @code{void} GetRGB (@code{char *}buf, @code{int} size)
@deftypefnx {Method on @code{mglGraph}} @code{void} GetBGRN (@code{char *}buf, @code{int} size)
@deftypefnx {C function} @code{const unsigned char *} mgl_get_rgb (@code{HMGL} gr)
Gets RGB bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue@}. Number of elements is Width*Height. Position of element @{i,j@} is [3*i + 3*Width*j] (or is [4*i + 4*Width*j] for @code{GetBGRN()}). You have to provide the proper @var{size} of the buffer, @var{buf}, i.e. the code for Python should look like
@verbatim
from mathgl import *
gr = mglGraph();
bits='\t';
bits=bits.expandtabs(4*gr.GetWidth()*gr.GetHeight());
gr.GetBGRN(bits, len(bits));
@end verbatim
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{const unsigned char *} GetRGBA ()
@deftypefnx {Method on @code{mglGraph}} @code{void} GetRGBA (@code{char *}buf, @code{int} size)
@deftypefnx {C function} @code{const unsigned char *} mgl_get_rgba (@code{HMGL} gr)
Gets RGBA bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue, alpha@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j].
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetWidth ()
@deftypefnx {Method on @code{mglGraph}} @code{int} GetHeight ()
@deftypefnx {C function} @code{int} mgl_get_width (@code{HMGL} gr)
@deftypefnx {C function} @code{int} mgl_get_height (@code{HMGL} gr)
Gets width and height of the image.
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{mglPoint} CalcXYZ (@code{int} xs, @code{int} ys)
@deftypefnx {C function} @code{void} mgl_calc_xyz (@code{HMGL} gr, @code{int} xs, @code{int} ys, @code{mreal *}x, @code{mreal *}y, @code{mreal *}z)
Calculate 3D coordinate @{x,y,z@} for screen point @{xs,ys@}. At this moment it ignore perspective and transformation formulas (curvilinear coordinates). The calculation are done for the last used InPlot (see @ref{Subplots and rotation}).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{mglPoint} CalcScr (@code{mglPoint} p)
@deftypefnx {C function} @code{void} mgl_calc_scr (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{int *}xs, @code{int *}ys)
Calculate screen point @{xs,ys@} for 3D coordinate @{x,y,z@}. The calculation are done for the last used InPlot (see @ref{Subplots and rotation}).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetObjId (@code{int} id)
@deftypefnx {C function} @code{void} mgl_set_obj_id (@code{HMGL} gr, @code{int} id)
Set the numeric id for object or subplot/inplot.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetObjId (@code{int} xs, @code{int} ys)
@deftypefnx {C function} @code{int} mgl_get_obj_id (@code{HMGL} gr, @code{int} xs, @code{int} ys)
Get the numeric id for most upper object at pixel @{xs, ys@} of the picture.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetSplId (@code{int} xs, @code{int} ys)
@deftypefnx {C function} @code{int} mgl_get_spl_id (@code{HMGL} gr, @code{int} xs, @code{int} ys)
Get the numeric id for most subplot/inplot at pixel @{xs, ys@} of the picture.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} Highlight (@code{int} id)
@deftypefnx {C function} @code{void} mgl_highlight (@code{HMGL} gr, @code{int} id)
Highlight the object with given @var{id}.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{long} IsActive (@code{int} xs, @code{int} ys, @code{int} d=@code{1})
@deftypefnx {C function} @code{long} mgl_is_active (@code{HMGL} gr, @code{int} xs, @code{int} ys, @code{int} d)
Checks if point @{@var{xs}, @var{ys}@} is close to one of active point (i.e. mglBase::Act) with accuracy @var{d} and return its index or @code{-1} if not found. Active points are special points which characterize primitives (like edges and so on). This function for advanced users only.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{long} SetDrawReg (@code{int} nx=@code{1}, @code{int} ny=@code{1}, @code{int} m=@code{0})
@deftypefnx {C function} @code{long} mgl_set_draw_reg (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m)
Limits drawing region by rectangular area of @var{m}-th cell of matrix with sizes @var{nx}*@var{ny} (like in @ref{subplot}). This function can be used to update only small region of the image for purposes of higher speed. This function for advanced users only.
@end deftypefn


@end ifclear

@c ------------------------------------------------------------------
@external{}
@node Parallelization, , Bitmap in memory, Export picture
@subsection Parallelization
@nav{}

@ifclear UDAV
@cindex Combine
@cindex MPI_Send
@cindex MPI_Recv

Many of things MathGL do in parallel by default (if MathGL was built with pthread). However, there is function which set the number of threads to be used.

@deftypefn {C function} @code{int} mgl_set_num_thr (@code{int} n)
Set the number of threads to be used by MathGL. If @var{n}<1 then the number of threads is set as maximal number of processors (cores). If @var{n}=1 then single thread will be used (this is default if pthread was disabled).
@end deftypefn

Another option is combining bitmap image (taking into account Z-ordering) from different instances of  @code{mglGraph}. This method is most appropriate for computer clusters when the data size is so large that it exceed the memory of single computer node.

@deftypefn {Method on @code{mglGraph}} @code{int} Combine (@code{const mglGraph *}g)
@deftypefnx {C function} @code{int} mgl_combine_gr (@code{HMGL} gr, @code{HMGL} g)
Combine drawing from instance @var{g} with @var{gr} (or with this) taking into account Z-ordering of pixels. The width and height of both instances must be the same.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} MPI_Send (@code{int} id)
@deftypefnx {C function} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Send graphical information from node @var{id} using MPI. The width and height in both nodes must be the same.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} MPI_Recv (@code{int} id)
@deftypefnx {C function} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Receive graphical information from node @var{id} using MPI. The width and height in both nodes must be the same.
@end deftypefn
@end ifclear


@c ##################################################################
@external{}
@node Background, Primitives, Export picture, MathGL core
@section Background
@nav{}
@cindex LoadBackground
@cindex Clf
@cindex Rasterize

These functions change background image.

@anchor{clf}
@deftypefn {MGL command} {} clf ['col']
@deftypefnx {MGL command} {} clf r g b
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf ()
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf (@code{const char *} col)
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf (@code{char} col)
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf (@code{mreal} r, @code{mreal} g, @code{mreal} b)
@deftypefnx {C function} @code{void} mgl_clf (@code{HMGL} gr)
@deftypefnx {C function} @code{void} mgl_clf_str (@code{HMGL} gr, @code{const char *} col)
@deftypefnx {C function} @code{void} mgl_clf_chr (@code{HMGL} gr, @code{char} col)
@deftypefnx {C function} @code{void} mgl_clf_rgb (@code{HMGL} gr, @code{mreal} r, @code{mreal} g, @code{mreal} b)
@end ifclear
Clear the picture and fill background by specified color.
@end deftypefn

@anchor{rasterize}
@deftypefn {MGL command} {} rasterize
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Rasterize ()
@deftypefnx {C function} @code{void} mgl_rasterize (@code{HMGL} gr)
@end ifclear
Force drawing the plot and use it as background. After it, function clear the list of primitives, like @ref{clf}. This function is useful if you want save part of plot as bitmap one (for example, large surfaces, isosurfaces or vector fields) and keep some parts as vector one (like annotation, curves, axis and so on).
@end deftypefn

@anchor{background}
@deftypefn {MGL command} {} background 'fname' [@code{alpha=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} LoadBackground (@code{const char *} fname, @code{double} alpha=@code{1})
@deftypefnx {C function} @code{void} mgl_load_background (@code{HMGL} gr, @code{const char *} fname, @code{double} alpha)
@end ifclear
Load PNG or JPEG file @var{fname} as background for the plot. Parameter @var{alpha} manually set transparency of the background.
@end deftypefn



@c ##################################################################
@external{}
@node Primitives, Text printing, Background, MathGL core
@section Primitives
@nav{}
@cindex Ball
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

@ifclear UDAV
@cindex Mark
@cindex Error
@end ifclear

These functions draw some simple objects like line, point, sphere, drop, cone and so on. @sref{Using primitives}

@anchor{ball}
@deftypefn {MGL command} {} ball @code{x y} ['col'='r.']
@deftypefnx {MGL command} {} ball @code{x y z} ['col'='r.']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ball (@code{mglPoint} p, @code{char} col=@code{'r'})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{mglPoint} p, @code{const char *}mark)
@deftypefnx {C function} @code{void} mgl_mark (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}mark)
@end ifclear
Draws a mark (point @samp{.} by default) at position @var{p}=@{@var{x}, @var{y}, @var{z}@} with color @var{col}.
@end deftypefn

@anchor{errbox}
@deftypefn {MGL command} {} errbox @code{x y ex ey} ['stl'='']
@deftypefnx {MGL command} {} errbox @code{x y z ex ey ez} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{mglPoint} p, @code{mglPoint} e, @code{char} *stl=@code{""})
@deftypefnx {C function} @code{void} mgl_error_box (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} ex, @code{mreal} ey, @code{mreal} ez, @code{char *}stl)
@end ifclear
Draws a 3d error box at position @var{p}=@{@var{x}, @var{y}, @var{z}@} with sizes @var{e}=@{@var{ex}, @var{ey}, @var{ez}@} and style @var{stl}. Use NAN for component of @var{e} to reduce number of drawn elements.
@end deftypefn

@anchor{line}
@deftypefn {MGL command} {} line @code{x1 y1 x2 y2} ['stl'='']
@deftypefnx {MGL command} {} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Line (@code{mglPoint} p1, @code{mglPoint} p2, @code{char *}stl=@code{"B"}, @code{int} num=@code{2})
@deftypefnx {C function} @code{void} mgl_line (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{char *}stl, @code{int} num)
@end ifclear
Draws a geodesic line (straight line in Cartesian coordinates) from point @var{p1} to @var{p2} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas (see @ref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on). Line will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{curve}
@deftypefn {MGL command} {} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deftypefnx {MGL command} {} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Curve (@code{mglPoint} p1, @code{mglPoint} d1, @code{mglPoint} p2, @code{mglPoint} d2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
@deftypefnx {C function} @code{void} mgl_curve (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} dx1, @code{mreal} dy1, @code{mreal} dz1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} dx2, @code{mreal} dy2, @code{mreal} dz2, @code{const char *}stl, @code{int} num)
@end ifclear
Draws Bezier-like curve from point @var{p1} to @var{p2} using line style @var{stl}. At this tangent is codirected with @var{d1}, @var{d2} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas, see @ref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordinate system. Curve will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{face}
@deftypefn {MGL command} {} face @code{x1 y1 x2 y2 x3 y3 x4 y4} ['stl'='']
@deftypefnx {MGL command} {} face @code{x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"})
@deftypefnx {C function} @code{void} mgl_face (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} x3, @code{mreal} y3, @code{mreal} z3, @code{mreal} x4, @code{mreal} y4, @code{mreal} z4, @code{const char *}stl)
@end ifclear
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Face will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{rect}
@deftypefn {MGL command} {} rect @code{x1 y1 x2 y2} ['stl'='']
@deftypefnx {MGL command} {} rect @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Draws the solid rectangle (face) with vertexes @{@var{x1}, @var{y1}, @var{z1}@} and @{@var{x2}, @var{y2}, @var{z2}@} with color @var{stl}. At this colors can be the same for all vertexes or separately if all 4 colors are specified for each vertex. Face will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{facex}
@anchor{facey}
@anchor{facez}
@deftypefn {MGL command} {} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {MGL command} {} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {MGL command} {} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceX (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wy, @code{mreal} wz, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceY (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wz, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceZ (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wy, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {C function} @code{void} mgl_facex (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wy, @code{mreal} wz, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@deftypefnx {C function} @code{void} mgl_facey (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wz, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@deftypefnx {C function} @code{void} mgl_facez (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wy, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@end ifclear
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or separately if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle). Face will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{sphere}
@deftypefn {MGL command} {} sphere @code{x0 y0 r} ['col'='r']
@deftypefnx {MGL command} {} sphere @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Sphere (@code{mglPoint} p, @code{mreal} r, @code{const char *}stl=@code{"r"})
@deftypefnx {C function} @code{void} mgl_sphere (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} r, @code{const char *}stl)
@end ifclear
Draw the sphere with radius @var{r} and center at point @var{p}=@{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deftypefn

@anchor{drop}
@deftypefn {MGL command} {} drop @code{x0 y0 dx dy r} ['col'='r' @code{sh=1 asp=1}]
@deftypefnx {MGL command} {} drop @code{x0 y0 z0 dx dy dz r} ['col'='r' @code{sh=1 asp=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Drop (@code{mglPoint} p, @code{mglPoint} d, @code{mreal} r, @code{const char *}col=@code{"r"}, @code{mreal} shift=@code{1}, @code{mreal} ap=@code{1})
@deftypefnx {C function} @code{void} mgl_drop (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{mreal} r, @code{const char *}col, @code{mreal} shift, @code{mreal} ap)
@end ifclear
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{d} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere).
@end deftypefn

@anchor{cone}
@deftypefn {MGL command} {} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cone (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r1, @code{mreal} r2=@code{-1}, @code{const char *}stl=@code{"B"})
@deftypefnx {C function} @code{void} mgl_cone (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r1, @code{mreal} r2, @code{const char *}stl)
@end ifclear
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @var{p1}, @var{p2} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is supposed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}. Parameter @var{stl} can contain:
@itemize @bullet
@item
@samp{@@} for drawing edges;
@item
@samp{#} for wired cones;
@item
@samp{t} for drawing tubes/cylinder instead of cones/prisms;
@item
@samp{4}, @samp{6}, @samp{8} for drawing square, hex- or octo-prism instead of cones.
@end itemize
@end deftypefn

@anchor{circle}
@deftypefn {MGL command} {} circle @code{x0 y0 r} ['col'='r']
@deftypefnx {MGL command} {} circle @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Circle (@code{mglPoint} p, @code{mreal} r, @code{const char *}stl=@code{"r"})
@end ifclear
Draw the circle with radius @var{r} and center at point @var{p}=@{@var{x0}, @var{y0}, @var{z0}@}. Parameter @var{col} may contain
@itemize @bullet
@item
colors for filling and boundary (second one if style @samp{@@} is used, black color is used by default);
@item
@samp{#} for wire figure (boundary only);
@item
@samp{@@} for filling and boundary.
@end itemize
@end deftypefn

@anchor{ellipse}
@deftypefn {MGL command} {} ellipse @code{x1 y1 x2 y2 r} ['col'='r']
@deftypefnx {MGL command} {} ellipse @code{x1 y1 z1 x2 y2 z2 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ellipse (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_ellipse (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r, @code{const char *}col)
@end ifclear
Draw the ellipse with radius @var{r} and focal points @var{p1}, @var{p2}. Parameter @var{col} may contain
@itemize @bullet
@item
colors for filling and boundary (second one if style @samp{@@} is used, black color is used by default);
@item
@samp{#} for wire figure (boundary only);
@item
@samp{@@} for filling and boundary.
@end itemize
@end deftypefn

@anchor{rhomb}
@deftypefn {MGL command} {} rhomb @code{x1 y1 x2 y2 r} ['col'='r']
@deftypefnx {MGL command} {} rhomb @code{x1 y1 z1 x2 y2 z2 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Rhomb (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_rhomb (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r, @code{const char *}col)
@end ifclear
Draw the rhombus with width @var{r} and edge points @var{p1}, @var{p2}. Parameter @var{col} may contain
@itemize @bullet
@item
colors for filling and boundary (second one if style @samp{@@} is used, black color is used by default);
@item
@samp{#} for wire figure (boundary only);
@item
@samp{@@} for filling and boundary.
@end itemize
@end deftypefn

@anchor{arc}
@deftypefn {MGL command} {} arc @code{x0 y0 x1 y1 a} ['col'='r']
@deftypefnx {MGL command} {} arc @code{x0 y0 z0 x1 y1 a} ['col'='r']
@deftypefnx {MGL command} {} arc @code{x0 y0 z0 xa ya za x1 y1 z1 a} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Arc (@code{mglPoint} p0, @code{mglPoint} p1, @code{mreal} a, @code{const char *}col=@code{"r"})
@deftypefnx {Method on @code{mglGraph}} @code{void} Arc (@code{mglPoint} p0, @code{mglPoint} pa, @code{mglPoint} p1, @code{mreal} a, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_arc (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} x1, @code{mreal} y1, @code{mreal} a, @code{const char *}col)
@deftypefnx {C function} @code{void} mgl_arc_ext (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} xa, @code{mreal} ya, @code{mreal} za, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} a, @code{const char *}col)
@end ifclear
Draw the arc around axis @var{pa} (default is z-axis @var{pa}=@{0,0,1@}) with center at @var{p0} and starting from point @var{p1}. Parameter @var{a} set the angle of arc in degree. Parameter @var{col} may contain color of the arc and arrow style for arc edges.
@end deftypefn

@anchor{polygon}
@deftypefn {MGL command} {} polygon @code{x0 y0 x1 y1 num} ['col'='r']
@deftypefnx {MGL command} {} polygon @code{x0 y0 z0 x1 y1 z1 num} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Polygon (@code{mglPoint} p0, @code{mglPoint} p1, @code{int} num, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_polygon (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{int} num, @code{const char *}col)
@end ifclear
Draw the polygon with @var{num} edges starting from @var{p1}. The center of polygon is located in @var{p0}. Parameter @var{col} may contain
@itemize @bullet
@item
colors for filling and boundary (second one if style @samp{@@} is used, black color is used by default);
@item
@samp{#} for wire figure (boundary only);
@item
@samp{@@} for filling and boundary.
@end itemize
@end deftypefn


@anchor{logo}
@deftypefn {MGL command} {} logo 'fname' [smooth=off]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Logo (@code{const char *}fname, @code{bool} smooth=@code{false}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Logo (@code{long} w, @code{long} h, @code{const unsigned char *}rgba, @code{bool} smooth=@code{false}, @code{const char *}opt=@code{""})
@deftypefnx {C function only} @code{void} mgl_logo (@code{HMGL} gr, @code{long} w, @code{long} h, @code{const unsigned char *}rgba, @code{bool} smooth, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_logo_file (@code{HMGL} gr, @code{const char *}fname, @code{bool} smooth, @code{const char *}opt)
@end ifclear
Draw bitmap (logo) along whole axis range, which can be changed by @ref{Command options}. Bitmap can be loaded from file or specified as RGBA values for pixels. Parameter @var{smooth} set to draw bitmap without or with color interpolation.
@end deftypefn


@anchor{symbol}
@deftypefn {MGL command} {} symbol @code{x y} 'id' ['fnt'='' @code{size=-1}]
@deftypefnx {MGL command} {} symbol @code{x y z} 'id' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Symbol (@code{mglPoint} p, @code{char} id, @code{const char *}fnt=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_symbol (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{char} id, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Draws user-defined symbol with name @var{id} at position @var{p} with style specifying by @var{fnt}. The size of font is set by @var{size} parameter (default is @code{-1}). The string @var{fnt} may contain color specification ended by @samp{:} symbol; styles @samp{a}, @samp{A} to draw at absolute position @{@var{x}, @var{y}@} (supposed to be in range [0,1]) of picture (for @samp{A}) or subplot/inplot (for @samp{a}); and style @samp{w} to draw wired symbol.
@end deftypefn

@deftypefn {MGL command} {} symbol @code{x y dx dy} 'id' ['fnt'=':L' @code{size=-1}]
@deftypefnx {MGL command} {} symbol @code{x y z dx dy dz} 'id' ['fnt'=':L' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Symbol (@code{mglPoint} p, @code{mglPoint} d, @code{char} id, @code{const char *}fnt=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_symbol_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
The same as previous but symbol will be drawn rotated along direction @var{d}.
@end deftypefn

@anchor{addsymbol}
@deftypefn {MGL command} {} addsymbol 'id' xdat ydat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} DefineSymbol (@code{char} id, @code{const mglDataA &}xdat, @code{const mglDataA &}ydat)
@deftypefnx {C function} @code{void} mgl_define_symbol (@code{HMGL} gr, @code{HCDT} xdat, @code{HCDT} ydat)
@end ifclear
Add user-defined symbol with name @var{id} and contour @{@var{xdat}, @var{ydat}@}. You can use @code{NAN} values to set break (jump) of contour curve.
@end deftypefn


@c ##################################################################
@external{}
@node Text printing, Axis and Colorbar, Primitives, MathGL core
@section Text printing
@nav{}
@ifclear UDAV
@cindex Puts
@cindex Putsw
@end ifclear
@cindex Text
@cindex Label
@cindex fgets

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. MathGL can use arbitrary font-faces and parse many TeX commands (for more details see @ref{Font styles}). All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion into the current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The @var{size} argument control the size of text: if positive it give the value, if negative it give the value relative to @code{SetFontSize()}. The font type (STIX, arial, courier, times and so on) can be selected by function LoadFont(). @xref{Font settings}.

The font parameters are described by string. This string may set the text color @samp{wkrgbcymhRGBCYMHW} (see @ref{Color styles}). Starting from MathGL v.2.3, you can set color gradient for text (see @ref{Color scheme}). Also,  after delimiter symbol @samp{:}, it can contain characters of font type (@samp{rbiwou}) and/or align (@samp{LRCTV}) specification. The font types are: @samp{r} -- roman (or regular) font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right, @samp{T} -- align under, @samp{V} -- align center vertical. For example, string @samp{b:iC} correspond to italic font style for centered text which printed by blue color.

If string contains symbols @samp{aA} then text is printed at absolute position @{@var{x}, @var{y}@} (supposed to be in range [0,1]) of picture (for @samp{A}) or subplot/inplot (for @samp{a}). If string contains symbol @samp{@@} then box around text is drawn.

@sref{Text features}

@anchor{text}
@deftypefn {MGL command} {} text @code{x y} 'text' ['fnt'='' @code{size=-1}]
@deftypefnx {MGL command} {} text @code{x y z} 'text' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{const char *}text, @code{const char *}fnt=@code{":C"}, @code{mreal} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}fnt=@code{":C"}, @code{mreal} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{mreal} x, @code{mreal} y, @code{const char *}text, @code{const char *}fnt=@code{":AC"}, @code{mreal} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{mreal} x, @code{mreal} y, @code{const wchar_t *}text, @code{const char *}fnt=@code{":AC"}, @code{mreal} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@deftypefnx {C function} @code{void} mgl_putsw (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Draws the string @var{text} at position @var{p} with fonts specifying by the criteria @var{fnt}. The size of font is set by @var{size} parameter (default is @code{-1}).
@end deftypefn

@deftypefn {MGL command} {} text @code{x y dx dy} 'text' ['fnt'=':L' @code{size=-1}]
@deftypefnx {MGL command} {} text @code{x y z dx dy dz} 'text' ['fnt'=':L' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{mglPoint} d, @code{const char *}text, @code{const char *}fnt=@code{":L"}, @code{mreal} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{mglPoint} d, @code{const wchar_t *}text, @code{const char *}fnt=@code{":L"}, @code{mreal} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@deftypefnx {C function} @code{void} mgl_putsw_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const wchar_t *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Draws the string @var{text} at position @var{p} along direction @var{d} with specified @var{size}. Parameter @var{fnt} set text style and text position: under (@samp{T}) or above (@samp{t}) the line.
@end deftypefn

@anchor{fgets}
@deftypefn {MGL command} {} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deftypefnx {MGL command} {} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Draws unrotated @var{n}-th line of file @var{fname} at position @{@var{x},@var{y},@var{z}@} with specified @var{size}. By default parameters from @ref{font} command are used.
@end deftypefn

@deftypefn {MGL command} {} text ydat 'text' ['fnt'='']
@deftypefnx {MGL command} {} text xdat ydat 'text' ['fnt'='']
@deftypefnx {MGL command} {} text xdat ydat zdat 'text' ['fnt'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_text_y (@code{HMGL} gr, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_y (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_text_xy (@code{HCDT} x, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_xy (@code{HCDT} x, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_text_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{fnt}. The string @var{fnt} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text under the curve. The sizes of 1st dimension must be equal for all arrays @code{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in x-axis range (see @ref{Ranges (bounding box)}). If array @var{z} is not specified then @var{z}[i] equal to minimal z-axis value is used. String @var{opt} contain command options (see @ref{Command options}).
@end deftypefn

@c ##################################################################
@external{}
@node Axis and Colorbar, Legend, Text printing, MathGL core
@section Axis and Colorbar
@nav{}
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information see @ref{Axis settings}.

@anchor{axis}
@deftypefn {MGL command} {} axis ['dir'='xyz' 'stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_axis (@code{HMGL} gr, @code{const char *}dir, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Draws axes with ticks (see @ref{Axis settings}). Parameter @var{dir} may contain:
@itemize @bullet
@item @samp{xyz} for drawing axis in corresponding direction;
@item @samp{XYZ} for drawing axis in corresponding direction but with inverted positions of labels;
@item @samp{~} or @samp{_} for disabling tick labels;
@item @samp{U} for disabling rotation of tick labels;
@item @samp{^} for inverting default axis origin;
@item @samp{!} for disabling ticks tuning (see @ref{tuneticks});
@item @samp{AKDTVISO} for drawing arrow at the end of axis;
@item @samp{a} for forced adjusting of axis ticks;
@item @samp{:} for drawing lines through point (0,0,0);
@item @samp{f} for printing ticks labels in fixed format;
@item @samp{E} for using @samp{E} instead of @samp{e} in ticks labels;
@item @samp{F} for printing ticks labels in LaTeX format;
@item @samp{+} for printing @samp{+} for positive ticks;
@item @samp{-} for printing usual @samp{-} in ticks labels;
@item @samp{0123456789} for precision at printing ticks labels.
@end itemize
Styles of ticks and axis can be overrided by using @var{stl} string. Option @code{value} set the manual rotation angle for the ticks. @sref{Axis and ticks}
@end deftypefn

@anchor{colorbar}
@deftypefn {MGL command} {} colorbar ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_colorbar (@code{HMGL} gr, @code{const char *}sch)
@end ifclear
Draws colorbar. Parameter @var{sch} may contain:
@itemize @bullet
@item
color scheme (see @ref{Color scheme});
@item @samp{<>^_} for positioning at left, at right, at top or at bottom correspondingly;
@item @samp{I} for positioning near bounding (by default, is positioned at edges of subplot);
@item @samp{A} for using absolute coordinates;
@item @samp{~} for disabling tick labels.
@item @samp{!} for disabling ticks tuning (see @ref{tuneticks});
@item @samp{f} for printing ticks labels in fixed format;
@item @samp{E} for using @samp{E} instead of @samp{e} in ticks labels;
@item @samp{F} for printing ticks labels in LaTeX format;
@item @samp{+} for printing @samp{+} for positive ticks;
@item @samp{-} for printing usual @samp{-} in ticks labels;
@item @samp{0123456789} for precision at printing ticks labels.
@end itemize
@sref{Colorbars}
@end deftypefn

@deftypefn {MGL command} {} colorbar vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const mglDataA &}v, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_colorbar_val (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch)
@end ifclear
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{contd sample}
@end deftypefn

@deftypefn {MGL command} {} colorbar 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w=@code{1}, @code{mreal} h=@code{1})
@deftypefnx {C function} @code{void} mgl_colorbar_ext (@code{HMGL} gr, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w, @code{mreal} h)
@end ifclear
The same as first one but at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypefn

@deftypefn {MGL command} {} colorbar vdat 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const mglDataA &}v, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w=@code{1}, @code{mreal} h=@code{1})
@deftypefnx {C function} @code{void} mgl_colorbar_val_ext (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w, @code{mreal} h)
@end ifclear
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{contd sample}
@end deftypefn

@anchor{grid}
@deftypefn {MGL command} {} grid ['dir'='xyz' 'pen'='B']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B"}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_axis_grid (@code{HMGL} gr, @code{const char *}dir, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. If @var{dir} contain @samp{!} then grid lines will be drawn at coordinates of subticks also. The step of grid lines is the same as tick step for @ref{axis}. The style of lines is determined by @var{pen} parameter (default value is dark blue solid line @samp{B-}).
@end deftypefn

@anchor{box}
@deftypefn {MGL command} {} box ['stl'='k' @code{ticks=on}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Box (@code{const char *}col=@code{""}, @code{bool} ticks=@code{true})
@deftypefnx {C function} @code{void} mgl_box (@code{HMGL} gr)
@deftypefnx {C function} @code{void} mgl_box_str (@code{HMGL} gr, @code{const char *}col, @code{int} ticks)
@end ifclear
Draws bounding box outside the plotting volume with color @var{col}. If @var{col} contain @samp{@@} then filled faces are drawn. At this first color is used for faces (default is light yellow), last one for edges. @sref{Bounding box}
@end deftypefn

@anchor{xlabel}
@anchor{ylabel}
@anchor{zlabel}
@anchor{tlabel}
@anchor{clabel}
@deftypefn {MGL command} {} xlabel 'text' [@code{pos=1}]
@deftypefnx {MGL command} {} ylabel 'text' [@code{pos=1}]
@deftypefnx {MGL command} {} zlabel 'text' [@code{pos=1}]
@deftypefnx {MGL command} {} tlabel 'text' [@code{pos=1}]
@deftypefnx {MGL command} {} clabel 'text' [@code{pos=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const char *}text, @code{mreal} pos=@code{1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const wchar_t *}text, @code{mreal} pos=@code{1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_label (@code{HMGL} gr, @code{char} dir, @code{const char *}text, @code{mreal} pos, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_labelw (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}text, @code{mreal} pos, @code{const char *}opt)
@end ifclear
Prints the label @var{text} for axis @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t},@samp{c}, where @samp{t} is ``ternary'' axis @math{t=1-x-y}; @samp{c} is color axis (should be called after @ref{colorbar}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. Option @code{value} set additional shifting of the label. @xref{Text printing}.
@end deftypefn

@c ##################################################################
@external{}
@node Legend, 1D plotting, Axis and Colorbar, MathGL core
@section Legend
@nav{}
@cindex Legend
@cindex AddLegend
@cindex ClearLegend
@cindex SetLegendBox
@cindex SetLegendMarks

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included TeX parsing). The arrays of strings may be used directly or by accumulating first to the internal arrays (by function @ref{addlegend}) and further plotting it. The position of the legend can be selected automatic or manually (even out of bounding box). Parameters @var{fnt} and @var{size} specify the font style and size (see @ref{Font settings}). Option @code{value} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. Parameter @var{fnt} may contain:
@itemize @bullet
@item
font style for legend text;
@item
@samp{A} for positioning in absolute coordinates;
@item
@samp{^} for positioning outside of specified point;
@item
@samp{#} for drawing box around legend;
@item
@samp{-} for arranging legend entries horizontally;
@item
colors for face (1st one), for border (2nd one) and for text (last one). If less than 3 colors are specified then the color for border is black (for 2 and less colors), and the color for face is white (for 1 or none colors).
@end itemize
@sref{Legend sample}

@anchor{legend}
@deftypefn {MGL command} {} legend [@code{pos=3} 'fnt'='#']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Legend (@code{int} pos=@code{0x3}, @code{const char *}fnt=@code{"#"}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_legend (@code{HMGL} gr, @code{int} pos, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Parameter @var{pos} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default). Option @code{value} set the space between line samples and text (default is 0.1).
@end deftypefn

@deftypefn {MGL command} {} legend @code{x y} ['fnt'='#']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Legend (@code{mreal} x, @code{mreal} y, @code{const char *}fnt=@code{"#"}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_legend_pos (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1]. Option @code{value} set the space between line samples and text (default is 0.1).
@end deftypefn

@anchor{addlegend}
@deftypefn {MGL command} {} addlegend 'text' 'stl'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legend (@code{HMGL} gr, @code{const char *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legendw (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}style)
@end ifclear
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (see @ref{Line styles}).
@end deftypefn

@anchor{clearlegend}
@deftypefn {MGL command} {} clearlegend
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ClearLegend ()
@deftypefnx {C function} @code{void} mgl_clear_legend (@code{HMGL} gr)
@end ifclear
Clears saved legend strings.
@end deftypefn

@anchor{legendmarks}
@deftypefn {MGL command} {} legendmarks @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetLegendMarks (@code{int} num)
@deftypefnx {C function} @code{void} mgl_set_legend_marks (@code{HMGL} gr, @code{int} num)
@end ifclear
Set the number of marks in the legend. By default 1 mark is used.
@end deftypefn

@c ##################################################################
@external{}
@node 1D plotting, 2D plotting, Legend, MathGL core
@section 1D plotting
@nav{}
@cindex Plot
@cindex Radar
@cindex Tens
@cindex Area
@cindex Region
@cindex Stem
@cindex Bars
@cindex Barh
@cindex Chart
@cindex Step
@cindex Torus
@cindex Tube
@cindex Mark
@cindex TextMark
@cindex Error
@cindex BoxPlot
@cindex Candle
@cindex Tape
@cindex Label
@cindex Cones

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x[i],y[i],z[i]@}, i=1...n. By default (if absent) values of @var{x}[i] are equidistantly distributed in axis range, and @var{z}[i] equal to minimal z-axis value. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}.

String @var{pen} specifies the color and style of line and marks (see @ref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (see @ref{Palette and colors}). Symbol @samp{!} set to use new color from palette for each point (not for each curve, as default). String @var{opt} contain command options (see @ref{Command options}).

@anchor{plot}
@deftypefn {MGL command} {} plot ydat ['stl'='']
@deftypefnx {MGL command} {} plot xdat ydat ['stl'='']
@deftypefnx {MGL command} {} plot xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_plot (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_plot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_plot_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. If @var{pen} contain @samp{a} then segments between points outside of axis range are drawn too. If @var{pen} contain @samp{~} then number of segments is reduce for quasi-straight curves. See also @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}, @ref{tape}, @ref{meshnum}. @sref{plot sample}
@end deftypefn

@anchor{radar}
@deftypefn {MGL command} {} radar adat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Radar (@code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_radar (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
This functions draws radar chart which is continuous lines between points located on an radial lines (like plot in Polar coordinates). Option @code{value} set the additional shift of data (i.e. the data @var{a}+@code{value} is used instead of @var{a}). If @code{value<0} then @code{r=max(0, -min(value)}. If @var{pen} containt @samp{#} symbol then "grid" (radial lines and circle for @var{r}) is drawn. If @var{pen} contain @samp{a} then segments between points outside of axis range are drawn too. See also @ref{plot}, @ref{meshnum}. @sref{radar sample}
@end deftypefn

@anchor{step}
@deftypefn {MGL command} {} step ydat ['stl'='']
@deftypefnx {MGL command} {} step xdat ydat ['stl'='']
@deftypefnx {MGL command} {} step xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_step (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_step_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_step_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous stairs for points to axis plane. If @var{x}.nx>@var{y}.nx then @var{x} set the edges of bars, rather than its central positions. See also @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}, @ref{meshnum}. @sref{step sample}
@end deftypefn

@anchor{tens}
@deftypefn {MGL command} {} tens ydat cdat ['stl'='']
@deftypefnx {MGL command} {} tens xdat ydat cdat ['stl'='']
@deftypefnx {MGL command} {} tens xdat ydat zdat cdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}y, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tens (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tens_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} with color defined by the special array @var{c}[i] (look like tension plot). String @var{pen} specifies the color scheme (see @ref{Color scheme}) and style and/or width of line (see @ref{Line styles}). If @var{pen} contain @samp{a} then segments between points outside of axis range are drawn too. If @var{pen} contain @samp{~} then number of segments is reduce for quasi-straight curves. See also @ref{plot}, @ref{mesh}, @ref{fall}, @ref{meshnum}. @sref{tens sample}
@end deftypefn

@anchor{tape}
@deftypefn {MGL command} {} tape ydat ['stl'='']
@deftypefnx {MGL command} {} tape xdat ydat ['stl'='']
@deftypefnx {MGL command} {} tape xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tape (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tape_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tape_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw tapes of normals for curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Initial tape(s) was selected in x-y plane (for @samp{x} in @var{pen}) and/or y-z plane (for @samp{x} in @var{pen}). The width of tape is proportional to @ref{barwidth} and can be changed by option @code{value}. See also @ref{plot}, @ref{flow}, @ref{barwidth}. @sref{tape sample}
@end deftypefn

@anchor{area}
@deftypefn {MGL command} {} area ydat ['stl'='']
@deftypefnx {MGL command} {} area xdat ydat ['stl'='']
@deftypefnx {MGL command} {} area xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_area (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_area_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_area_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points and fills it to axis plane. Also you can use gradient filling if number of specified colors is equal to 2*number of curves. If @var{pen} contain @samp{#} then wired plot is drawn. If @var{pen} contain @samp{a} then segments between points outside of axis range are drawn too. See also @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{area sample}
@end deftypefn

@anchor{region}
@deftypefn {MGL command} {} region ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} region xdat ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} region xdat1 ydat1 xdat2 ydat2 ['stl'='']
@deftypefnx {MGL command} {} region xdat1 ydat1 zdat1 xdat2 ydat2 zdat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x1, @code{const mglDataA &}y1, @code{const mglDataA &}x2, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x1, @code{const mglDataA &}y1, @code{const mglDataA &}z1, @code{const mglDataA &}x2, @code{const mglDataA &}y2, @code{const mglDataA &}z2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_region (@code{HMGL} gr, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_region_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_region_3d (@code{HMGL} gr, @code{HCDT} x1, @code{HCDT} y1, @code{HCDT} z1, @code{HCDT} x2, @code{HCDT} y2, @code{HCDT} z2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions fill area between 2 curves. Dimensions of arrays @var{y1} and @var{y2} must be equal. Also you can use gradient filling if number of specified colors is equal to 2*number of curves. If for 2D version @var{pen} contain symbol @samp{i} then only area with y1<y<y2 will be filled else the area with y2<y<y1 will be filled too. If @var{pen} contain @samp{#} then wired plot is drawn. If @var{pen} contain @samp{a} then segments between points outside of axis range are drawn too. See also @ref{area}, @ref{bars}, @ref{stem}. @sref{region sample}
@end deftypefn

@anchor{stem}
@deftypefn {MGL command} {} stem ydat ['stl'='']
@deftypefnx {MGL command} {} stem xdat ydat ['stl'='']
@deftypefnx {MGL command} {} stem xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_stem (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stem_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stem_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw vertical lines from points to axis plane. See also @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{stem sample}
@end deftypefn

@anchor{bars}
@deftypefn {MGL command} {} bars ydat ['stl'='']
@deftypefnx {MGL command} {} bars xdat ydat ['stl'='']
@deftypefnx {MGL command} {} bars xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_bars (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_bars_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_bars_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw vertical bars from points to axis plane. Parameter @var{pen} can contain:
@itemize @bullet
@item
@samp{a} for drawing lines one above another (like summation);
@item
@samp{f} for drawing waterfall chart, which show the cumulative effect of sequential positive or negative values;
@item
@samp{F} for using fixed (minimal) width for all bars;
@item
@samp{<}, @samp{^} or @samp{>} for aligning boxes left, right or centering them at its x-coordinates.
@end itemize
You can give different colors for positive and negative values if number of specified colors is equal to 2*number of curves. If @var{x}.nx>@var{y}.nx then @var{x} set the edges of bars, rather than its central positions. See also @ref{barh}, @ref{cones}, @ref{area}, @ref{stem}, @ref{chart}, @ref{barwidth}. @sref{bars sample}
@end deftypefn

@anchor{barh}
@deftypefn {MGL command} {} barh vdat ['stl'='']
@deftypefnx {MGL command} {} barh ydat vdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Barh (@code{const mglDataA &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Barh (@code{const mglDataA &}y, @code{const mglDataA &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_barh (@code{HMGL} gr, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_barh_xy (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw horizontal bars from points to axis plane. Parameter @var{pen} can contain:
@itemize @bullet
@item
@samp{a} for drawing lines one above another (like summation);
@item
@samp{f} for drawing waterfall chart, which show the cumulative effect of sequential positive or negative values;
@item
@samp{F} for using fixed (minimal) width for all bars;
@item
@samp{<}, @samp{^} or @samp{>} for aligning boxes left, right or centering them at its x-coordinates.
@end itemize
You can give different colors for positive and negative values if number of specified colors is equal to 2*number of curves. If @var{x}.nx>@var{y}.nx then @var{x} set the edges of bars, rather than its central positions. See also @ref{bars}, @ref{barwidth}. @sref{barh sample}
@end deftypefn

@anchor{cones}
@deftypefn {MGL command} {} cones ydat ['stl'='']
@deftypefnx {MGL command} {} cones xdat ydat ['stl'='']
@deftypefnx {MGL command} {} cones xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cones (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cones_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cones_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw cones from points to axis plane. If string contain symbol @samp{a} then cones are drawn one above another (like summation). You can give different colors for positive and negative values if number of specified colors is equal to 2*number of curves. Parameter @var{pen} can contain:
@itemize @bullet
@item
@samp{@@} for drawing edges;
@item
@samp{#} for wired cones;
@item
@samp{t} for drawing tubes/cylinders instead of cones/prisms;
@item
@samp{4}, @samp{6}, @samp{8} for drawing square, hex- or octo-prism instead of cones;
@item
@samp{<}, @samp{^} or @samp{>} for aligning boxes left, right or centering them at its x-coordinates.
@end itemize
See also @ref{bars}, @ref{cone}, @ref{barwidth}. @sref{cones sample}
@end deftypefn



@anchor{chart}
@deftypefn {MGL command} {} chart adat ['col'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Chart (@code{const mglDataA &}a, @code{const char *}col=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_chart (@code{HMGL} gr, @code{HCDT} a, @code{const char *}col, @code{const char *}opt)
@end ifclear
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (see @ref{Palette and colors}). Spaces in colors denote transparent ``color'' (i.e. corresponding stripe(s) are not drawn). The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{chart sample}
@end deftypefn

@anchor{boxplot}
@deftypefn {MGL command} {} boxplot adat ['stl'='']
@deftypefnx {MGL command} {} boxplot xdat adat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} BoxPlot (@code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} BoxPlot (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_boxplot (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_boxplot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw boxplot (also known as a box-and-whisker diagram) at points @var{x}[i]. This is five-number summaries of data @var{a}[i,j] (minimum, lower quartile (Q1), median (Q2), upper quartile (Q3) and maximum) along second (j-th) direction. If @var{pen} contain @samp{<}, @samp{^} or @samp{>} then boxes will be aligned left, right or centered at its x-coordinates. See also @ref{plot}, @ref{error}, @ref{bars}, @ref{barwidth}. @sref{boxplot sample}
@end deftypefn

@anchor{candle}
@deftypefn {MGL command} {} candle vdat1 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 vdat2 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 vdat2 ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} candle xdat vdat1 vdat2 ydat1 ydat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}x, @code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_candle (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_candle_yv (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_candle_xyv (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw candlestick chart at points @var{x}[i]. This is a combination of a line-chart and a bar-chart, in that each bar represents the range of price movement over a given time interval. Wire (or white) candle correspond to price growth @var{v1}[i]<@var{v2}[i], opposite case -- solid (or dark) candle. You can give different colors for growth and decrease values if number of specified colors is equal to 2. If @var{pen} contain @samp{#} then the wire candle will be used even for 2-color scheme. "Shadows" show the minimal @var{y1} and maximal @var{y2} prices. If @var{v2} is absent then it is determined as @var{v2}[i]=@var{v1}[i+1]. See also @ref{plot}, @ref{bars}, @ref{ohlc}, @ref{barwidth}. @sref{candle sample}
@end deftypefn

@anchor{ohlc}
@deftypefn {MGL command} {} ohlc odat hdat ldat cdat ['stl'='']
@deftypefnx {MGL command} {} ohlc xdat odat hdat ldat cdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} OHLC (@code{const mglDataA &}o, @code{const mglDataA &}h, @code{const mglDataA &}l, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} OHLC (@code{const mglDataA &}x, @code{const mglDataA &}o, @code{const mglDataA &}h, @code{const mglDataA &}l, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_ohlc (@code{HMGL} gr, @code{HCDT} o, @code{HCDT} h, @code{HCDT} l, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_ohlc_x (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} o, @code{HCDT} h, @code{HCDT} l, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw Open-High-Low-Close diagram. This diagram show vertical line for between maximal(high @var{h}) and minimal(low @var{l}) values, as well as horizontal lines before/after vertical line for initial(open @var{o})/final(close @var{c}) values of some process (usually price). You can give different colors for up and down values (when closing values higher or not as in previous point) if number of specified colors is equal to 2*number of curves. See also @ref{candle}, @ref{plot}, @ref{barwidth}. @sref{ohlc sample}
@end deftypefn


@anchor{error}
@deftypefn {MGL command} {} error ydat yerr ['stl'='']
@deftypefnx {MGL command} {} error xdat ydat yerr ['stl'='']
@deftypefnx {MGL command} {} error xdat ydat xerr yerr ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglDataA &}y, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ex, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_error (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_error_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_error_exy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ex, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw error boxes @{@var{ex}[i], @var{ey}[i]@} at points @{@var{x}[i], @var{y}[i]@}. This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. If string @var{pen} contain symbol @samp{@@} than large semitransparent mark is used instead of error box. See also @ref{plot}, @ref{mark}. @sref{error sample}
@end deftypefn

@anchor{mark}
@deftypefn {MGL command} {} mark ydat rdat ['stl'='']
@deftypefnx {MGL command} {} mark xdat ydat rdat ['stl'='']
@deftypefnx {MGL command} {} mark xdat ydat zdat rdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_mark_y (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mark_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mark_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw marks with size @var{r}[i]*@ref{marksize} at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. If you need to draw markers of the same size then you can use @ref{plot} function with empty line style @samp{ }. For markers with size in axis range use @ref{error} with style @samp{@@}. See also @ref{plot}, @ref{textmark}, @ref{error}, @ref{stem}, @ref{meshnum}. @sref{mark sample}
@end deftypefn

@anchor{textmark}
@deftypefn {MGL command} {} textmark ydat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark ydat rdat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark xdat ydat rdat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark xdat ydat zdat rdat 'txt' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmark (@code{HMGL} gr, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
These functions draw string @var{txt} as marks with size proportional to @var{r}[i]*@var{marksize} at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. By default (if omitted) @var{r}[i]=1. See also @ref{plot}, @ref{mark}, @ref{stem}, @ref{meshnum}. @sref{textmark sample}
@end deftypefn

@anchor{label}
@deftypefn {MGL command} {} label ydat 'txt' ['stl'='']
@deftypefnx {MGL command} {} label xdat ydat 'txt' ['stl'='']
@deftypefnx {MGL command} {} label xdat ydat zdat 'txt' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_label (@code{HMGL} gr, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_labelw (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_label_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_labelw_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_label_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_labelw_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
These functions draw string @var{txt} at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. If string @var{txt} contain @samp{%x}, @samp{%y}, @samp{%z} or @samp{%n} then it will be replaced by the value of x-,y-,z-coordinate of the point or its index. String @var{fnt} may contain:
@itemize
@item font style @ref{Font styles};
@item @samp{f} for fixed format of printed numbers;
@item @samp{E} for using @samp{E} instead of @samp{e};
@item @samp{F} for printing in LaTeX format;
@item @samp{+} for printing @samp{+} for positive numbers;
@item @samp{-} for printing usual @samp{-};
@item @samp{0123456789} for precision at printing numbers.
@end itemize
See also @ref{plot}, @ref{mark}, @ref{textmark}, @ref{table}. @sref{label sample}
@end deftypefn

@anchor{table}
@deftypefn {MGL command} {} table vdat 'txt' ['stl'='#']
@deftypefnx {MGL command} {} table x y vdat 'txt' ['stl'='#']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Table (@code{const mglDataA &}val, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Table (@code{const mglDataA &}val, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Table (@code{mreal} x, @code{mreal} y, @code{const mglDataA &}val, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Table (@code{mreal} x, @code{mreal} y, @code{const mglDataA &}val, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_table (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{HCDT} val, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tablew (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{HCDT} val, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
These functions draw table with values of @var{val} and captions from string @var{txt} (separated by newline symbol @samp{\n}) at points @{@var{x}, @var{y}@} (default at @{0,0@}) related to current subplot. String @var{fnt} may contain:
@itemize
@item font style @ref{Font styles};
@item @samp{#} for drawing cell borders;
@item @samp{|} for limiting table widh by subplot one (equal to option @samp{value 1});
@item @samp{=} for equal width of all cells;
@item @samp{f} for fixed format of printed numbers;
@item @samp{E} for using @samp{E} instead of @samp{e};
@item @samp{F} for printing in LaTeX format;
@item @samp{+} for printing @samp{+} for positive numbers;
@item @samp{-} for printing usual @samp{-};
@item @samp{0123456789} for precision at printing numbers.
@end itemize
Option @code{value} set the width of the table (default is 1). See also @ref{plot}, @ref{label}. @sref{table sample}
@end deftypefn

@anchor{iris}
@deftypefn {MGL command} {} iris dats 'ids' ['stl'='']
@deftypefnx {MGL command} {} iris dats rngs 'ids' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const char *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const wchar_t *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const mglDataA &}rngs, @code{const char *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const mglDataA &}rngs, @code{const wchar_t *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_iris_1 (@code{HMGL} gr, @code{HCDT} dats, @code{const char *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_irisw_1 (@code{HMGL} gr, @code{HCDT} dats, @code{const wchar_t *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_iris (@code{HMGL} gr, @code{HCDT} dats, @code{HCDT} rngs, @code{const char *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_irisw (@code{HMGL} gr, @code{HCDT} dats, @code{HCDT} rngs, @code{const wchar_t *}ids, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Draws Iris plots for determining cross-dependences of data arrays @var{dats} (see @uref{http://en.wikipedia.org/wiki/Iris_flower_data_set}). Data @var{rngs} of size 2*@var{dats}.nx provide manual axis ranges for each column. String @var{ids} contain column names, separated by @samp{;} symbol. Option @code{value} set the text size for column names. You can add another data set to existing Iris plot by providing the same ranges @var{rngs} and empty column names @var{ids}. See also @ref{plot}. @sref{iris sample}
@end deftypefn

@anchor{tube}
@deftypefn {MGL command} {} tube ydat rdat ['stl'='']
@deftypefnx {MGL command} {} tube ydat @code{rval} ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat rdat ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat @code{rval} ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat zdat rdat ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat zdat @code{rval} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}y, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tube_r (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube (@code{HMGL} gr, @code{HCDT} y, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Option @code{value} set the number of segments at cross-section (default is 25). See also @ref{plot}. @sref{tube sample}
@end deftypefn

@anchor{torus}
@deftypefn {MGL command} {} torus rdat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Torus (@code{const mglDataA &}r, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_torus (@code{HMGL} gr, @code{HCDT} r, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around axis. If string @var{pen} contain symbols @samp{x} or @samp{z} then rotation axis will be set to specified direction (default is @samp{y}). If string @var{pen} have symbol @samp{#} then wire plot is produced. If string @var{pen} have symbol @samp{.} then plot by dots is produced. See also @ref{plot}, @ref{axial}. @sref{torus sample}
@end deftypefn

@anchor{lamerey}
@deftypefn {MGL command} {} lamerey @code{x0} ydat ['stl'='']
@deftypefnx {MGL command} {} lamerey @code{x0} 'y(x)' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Lamerey (@code{double} x0, @code{const mglDataA &}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Lamerey (@code{double} x0, @code{const char *}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_lamerey_dat (@code{HMGL} gr, @code{double} x0, @code{HCDT} y, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_lamerey_str (@code{HMGL} gr, @code{double} x0, @code{const char *}y, @code{const char *}stl, @code{const char *}opt)
@end ifclear
These functions draw Lamerey diagram for mapping x_new = y(x_old) starting from point @var{x0}. String @var{stl} may contain line style, symbol @samp{v} for drawing arrows, symbol @samp{~} for disabling first segment. Option @code{value} set the number of segments to be drawn (default is 20). See also @ref{plot}, @ref{fplot}, @ref{bifurcation}, @ref{pmap}. @sref{lamerey sample}
@end deftypefn

@anchor{bifurcation}
@deftypefn {MGL command} {} bifurcation @code{dx} ydat ['stl'='']
@deftypefnx {MGL command} {} bifurcation @code{dx} 'y(x)' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Bifurcation (@code{double} dx, @code{const mglDataA &}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Bifurcation (@code{double} dx, @code{const char *}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_bifurcation_dat (@code{HMGL} gr, @code{double} dx, @code{HCDT} y, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_bifurcation_str (@code{HMGL} gr, @code{double} dx, @code{const char *}y, @code{const char *}stl, @code{const char *}opt)
@end ifclear
These functions draw bifurcation diagram for mapping x_new = y(x_old). Parameter @var{dx} set the accuracy along x-direction. String @var{stl} set color. Option @code{value} set the number of stationary points (default is 1024). See also @ref{plot}, @ref{fplot}, @ref{lamerey}. @sref{bifurcation sample}
@end deftypefn

@anchor{pmap}
@deftypefn {MGL command} {} pmap ydat sdat ['stl'='']
@deftypefnx {MGL command} {} pmap xdat ydat sdat ['stl'='']
@deftypefnx {MGL command} {} pmap xdat ydat zdat sdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}y, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_pmap (@code{HMGL} gr, @code{HMDT} y, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pmap_xy (@code{HMGL} gr, @code{HCDT} x, @code{HMDT} y, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pmap_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HMDT} y, @code{HCDT} z, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@end ifclear
These functions draw Poincare map for curve @{@var{x}, @var{y}, @var{z}@} at surface @var{s}=0. Basically, it show intersections of the curve and the surface. String @var{stl} set the style of marks. See also @ref{plot}, @ref{mark}, @ref{lamerey}. @sref{pmap sample}
@end deftypefn


@c ##################################################################
@external{}
@node 2D plotting, 3D plotting, 1D plotting, MathGL core
@section 2D plotting
@nav{}
@cindex Mesh
@cindex Fall
@cindex Belt
@cindex Surf
@cindex Boxs
@cindex Tile
@cindex Dens
@cindex Cont
@cindex ContF
@cindex ContD
@cindex Axial
@cindex Grad
@cindex Grid

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}.  By default (if absent) values of @var{x}, @var{y} are equidistantly distributed in axis range. The plots are drawn for each z slice of the data. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. String @var{opt} contain command options (see @ref{Command options}).

@anchor{surf}
@deftypefn {MGL command} {} surf zdat ['sch'='']
@deftypefnx {MGL command} {} surf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{.} then plot by dots is produced. See also @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{surf sample}
@end deftypefn

@anchor{mesh}
@deftypefn {MGL command} {} mesh zdat ['sch'='']
@deftypefnx {MGL command} {} mesh xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Mesh (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mesh (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_mesh (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mesh_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. See also @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{mesh sample}
@end deftypefn

@anchor{fall}
@deftypefn {MGL command} {} fall zdat ['sch'='']
@deftypefnx {MGL command} {} fall xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fall (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fall (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fall (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_fall_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used for plotting several curves shifted in depth one from another. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. See also @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{fall sample}
@end deftypefn

@anchor{belt}
@deftypefn {MGL command} {} belt zdat ['sch'='']
@deftypefnx {MGL command} {} belt xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Belt (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Belt (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_belt (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_belt_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of @ref{plot}). If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. See also @ref{fall}, @ref{surf}, @ref{beltc}, @ref{plot}, @ref{meshnum}. @sref{belt sample}
@end deftypefn

@anchor{boxs}
@deftypefn {MGL command} {} boxs zdat ['sch'='']
@deftypefnx {MGL command} {} boxs xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Boxs (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Boxs (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_boxs (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_boxs_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Symbol @samp{@@} in @var{sch} set to draw filled boxes. See also @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{boxs sample}
@end deftypefn

@anchor{tile}
@deftypefn {MGL command} {} tile zdat ['sch'='']
@deftypefnx {MGL command} {} tile xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} tile xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tile (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tile_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tile_xyc (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j] (@var{c}=@var{z} if @var{c} is not provided). If string @var{sch} contain style @samp{x} or @samp{y} then tiles will be oriented perpendicular to x- or y-axis. Such plot can be used as 3d generalization of @ref{step}. See also @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{tile sample}
@end deftypefn

@anchor{dens}
@deftypefn {MGL command} {} dens zdat ['sch'='']
@deftypefnx {MGL command} {} dens xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{mreal} zVal=@code{NAN})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{mreal} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} equal to minimal z-axis value. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{.} then plot by dots is produced. See also @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{dens sample}
@end deftypefn

@anchor{cont}
@deftypefn {MGL command} {} cont vdat zdat ['sch'='']
@deftypefnx {MGL command} {} cont vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k], or at @var{z} equal to minimal z-axis value if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. See also @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{cont sample}
@end deftypefn

@deftypefn {MGL command} {} cont zdat ['sch'='']
@deftypefnx {MGL command} {} cont xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7). If string @var{sch} contain symbol @samp{.} then only contours at levels with saddle points will be drawn.
@end deftypefn

@deftypefn  {MGL command} {} cont @code{val} adat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContGen (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_gen (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{a}[i,j]=@var{val}. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours.
@end deftypefn

@anchor{contf}
@deftypefn {MGL command} {} contf vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contf vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k], or at @var{z} equal to minimal z-axis value if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). See also @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{contf sample}
@end deftypefn

@deftypefn {MGL command} {} contf zdat ['sch'='']
@deftypefnx {MGL command} {} contf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn

@deftypefn  {MGL command} {} contf @code{v1 v2} adat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFGen (@code{mreal} v1, @code{mreal} v2, @code{const mglDataA &}a, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_gen (@code{HMGL} gr, @code{mreal} v1, @code{mreal} v2, @code{HCDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} between @var{a}[i,j]=@var{v1} and @var{a}[i,j]=@var{v2}.
@end deftypefn

@anchor{contd}
@deftypefn {MGL command} {} contd vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contd vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contd_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contd_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k] (or at @var{z} equal to minimal z-axis value if @var{sch} contain symbol @samp{_}) with manual colors. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the contour colors: the color of k-th contour is determined by character @code{sch[k%strlen(sch)]}. See also @ref{dens}, @ref{cont}, @ref{contf}. @sref{contd sample}
@end deftypefn

@deftypefn {MGL command} {} contd zdat ['sch'='']
@deftypefnx {MGL command} {} contd xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contd (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contd_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contp}
@deftypefn {MGL command} {} contp vdat xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContP (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contp_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws contour lines on surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{a}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. If string @var{sch} have symbol @samp{f} then solid contours will be drawn. See also @ref{cont}, @ref{contf}, @ref{surfc}, @code{cont[xyz]}. @c TODO @sref{contp sample}
@end deftypefn

@deftypefn {MGL command} {} contp xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContP (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contp (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn


@anchor{contv}
@deftypefn {MGL command} {} contv vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contv vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contv_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contv_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vertical cylinder (tube) at contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k], or at @var{z} equal to minimal z-axis value if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. See also @ref{cont}, @ref{contf}. @sref{contv sample}
@end deftypefn

@deftypefn {MGL command} {} contv zdat ['sch'='']
@deftypefnx {MGL command} {} contv xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contv (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contv_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{axial}
@deftypefn {MGL command} {} axial vdat zdat ['sch'='']
@deftypefnx {MGL command} {} axial vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_axial_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_axial_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string @var{sch} have symbol @samp{.} then plot by dots is produced. If string contain symbols @samp{x} or @samp{z} then rotation axis will be set to specified direction (default is @samp{y}). See also @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{axial sample}
@end deftypefn

@deftypefn {MGL command} {} axial zdat ['sch'='']
@deftypefnx {MGL command} {} axial xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_axial (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_axial_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{grid2}
@deftypefn {MGL command} {} grid2 zdat ['sch'='']
@deftypefnx {MGL command} {} grid2 xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grid (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grid_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} equal to minimal z-axis value. See also @ref{dens}, @ref{cont}, @ref{contf}, @ref{grid3}, @ref{meshnum}.
@end deftypefn


@c ##################################################################
@external{}
@node 3D plotting, Dual plotting, 2D plotting, MathGL core
@section 3D plotting
@nav{}
@cindex Surf3
@cindex Dens3
@cindex Cont3
@cindex ContF3
@cindex Grid3
@cindex Cloud
@cindex Beam

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{a} should be equal @code{x.nx=a.nx && y.nx=a.ny && z.nz=a.nz} or @code{x.nx=y.nx=z.nx=a.nx && x.ny=y.ny=z.ny=a.ny && x.nz=y.nz=z.nz=a.nz}. Arrays @var{x}, @var{y} and @var{z} can be vectors (not matrices as @var{a}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. String @var{opt} contain command options (see @ref{Command options}).

@anchor{surf3}
@deftypefn {MGL command} {} surf3 adat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3 xdat ydat zdat adat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{mreal} val, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. If string contain @samp{#} then wire plot is produced. If string @var{sch} have symbol @samp{.} then plot by dots is produced. Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{surf3 sample}
@end deftypefn

@deftypefn {MGL command} {} surf3 adat ['sch'='']
@deftypefnx {MGL command} {} surf3 xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{cloud}
@deftypefn {MGL command} {} cloud adat ['sch'='']
@deftypefnx {MGL command} {} cloud xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cloud (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cloud (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cloud (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cloud_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on @ref{meshnum}. If string @var{sch} contain symbol @samp{.} then lower quality plot will produced with much low memory usage. If string @var{sch} contain symbol @samp{i} then transparency will be inversed, i.e. higher become transparent and lower become not transparent. See also @ref{surf3}, @ref{meshnum}. @sref{cloud sample}
@end deftypefn

@anchor{dens3}
@deftypefn {MGL command} {} dens3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} dens3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{dens3 sample}
@end deftypefn

@anchor{cont3}
@deftypefn {MGL command} {} cont3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} cont3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels will be drawn below (or above) the contours. See also @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{cont3 sample}
@end deftypefn

@deftypefn {MGL command} {} cont3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} cont3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contf3}
@deftypefn {MGL command} {} contf3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} contf3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{sch} have symbol @samp{#} then grid lines are drawn. See also @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{contf3 sample}
@end deftypefn

@deftypefn {MGL command} {} contf3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} contf3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{grid3}
@deftypefn {MGL command} {} grid3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} grid3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grid3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Grid is plotted at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). See also @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}, @ref{meshnum}.
@end deftypefn

@anchor{beam}
@deftypefn {MGL command} {} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Beam (@code{const mglDataA &}tr, @code{const mglDataA &}g1, @code{const mglDataA &}g2, @code{const mglDataA &}a, @code{mreal} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0}, @code{int} num=@code{3})
@deftypefnx {Method on @code{mglGraph}} @code{void} Beam (@code{mreal} val, @code{const mglDataA &}tr, @code{const mglDataA &}g1, @code{const mglDataA &}g2, @code{const mglDataA &}a, @code{mreal} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_beam (@code{HMGL} gr, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{mreal} r, @code{const char *}stl, @code{int} flag, @code{int} num)
@deftypefnx {C function} @code{void} mgl_beam_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{mreal} r, @code{const char *}stl, @code{int} flag)
@end ifclear
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. See also @ref{surf3}.
@end deftypefn


@c ##################################################################
@external{}
@node Dual plotting, Vector fields, 3D plotting, MathGL core
@section Dual plotting
@nav{}
@cindex SurfC
@cindex SurfA
@cindex Surf3C
@cindex Surf3A
@cindex TileS
@cindex Map
@cindex STFA

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{c} should be equal. Arrays @var{x}, @var{y} (and @var{z} for @code{Surf3C, Surf3A}) can be vectors (not matrices as @var{c}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. String @var{opt} contain command options (see @ref{Command options}).

@anchor{surfc}
@deftypefn {MGL command} {} surfc zdat cdat ['sch'='']
@deftypefnx {MGL command} {} surfc xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfC (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfC (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surfc (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surfc_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{.} then plot by dots is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Surface is plotted for each z slice of the data. See also @ref{surf}, @ref{surfa}, @ref{surfca}, @ref{beltc}, @ref{surf3c}. @sref{surfc sample}
@end deftypefn


@anchor{beltc}
@deftypefn {MGL command} {} beltc zdat cdat ['sch'='']
@deftypefnx {MGL command} {} beltc xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} BeltC (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} BeltC (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_beltc (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_beltc_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. This plot can be used as 3d generalization of @ref{plot}). If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. See also @ref{belt}, @ref{surfc}, @ref{meshnum}. @c TODO @sref{beltc sample}
@end deftypefn



@anchor{surf3c}
@deftypefn {MGL command} {} surf3c adat cdat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3c_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} function but the color of isosurface depends on values of array @var{c}. If string @var{sch} contain @samp{#} then wire plot is produced. If string @var{sch} have symbol @samp{.} then plot by dots is produced. See also @ref{surf3}, @ref{surfc}, @ref{surf3a}, @ref{surf3ca}. @sref{surf3c sample}
@end deftypefn

@deftypefn {MGL command} {} surf3c adat cdat ['sch'='']
@deftypefnx {MGL command} {} surf3c xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3c_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. Here @var{num} is equal to parameter @code{value} in options @var{opt} (default is 3).
@end deftypefn


@anchor{surfa}
@deftypefn {MGL command} {} surfa zdat cdat ['sch'='']
@deftypefnx {MGL command} {} surfa xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfA (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surfa (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{.} then plot by dots is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Surface is plotted for each z slice of the data. See also @ref{surf}, @ref{surfc}, @ref{surfca}, @ref{surf3a}. @sref{surfa sample}
@end deftypefn

@anchor{surf3a}
@deftypefn {MGL command} {} surf3a adat cdat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3a_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} function but the transparency of isosurface depends on values of array @var{c}. If string @var{sch} contain @samp{#} then wire plot is produced. If string @var{sch} have symbol @samp{.} then plot by dots is produced. See also @ref{surf3}, @ref{surfc}, @ref{surf3a}, @ref{surf3ca}. @sref{surf3a sample}
@end deftypefn

@deftypefn {MGL command} {} surf3a adat cdat ['sch'='']
@deftypefnx {MGL command} {} surf3a xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3a_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. At this array @var{c} can be vector with values of transparency and @var{num}=@var{c}.nx. In opposite case @var{num} is equal to parameter @code{value} in options @var{opt} (default is 3).
@end deftypefn



@anchor{surfca}
@deftypefn {MGL command} {} surfca zdat cdat adat ['sch'='']
@deftypefnx {MGL command} {} surfca xdat ydat zdat cdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfCA (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfCA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surfca (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surfca_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}, color it by matrix @var{c}[i,j] and transparent it by matrix @var{a}[i,j]. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{.} then plot by dots is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Surface is plotted for each z slice of the data. Note, you can use @ref{map}-like coloring if use @samp{%} in color scheme. See also @ref{surf}, @ref{surfc}, @ref{surfa}, @ref{surf3ca}. @sref{surfca sample}
@end deftypefn

@anchor{surf3ca}
@deftypefn {MGL command} {} surf3ca adat cdat bdat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3ca xdat ydat zdat adat cdat bdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3CA (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3CA (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3ca_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3ca_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b,@code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} function but the color and the transparency of isosurface depends on values of array @var{c} and @var{b} correspondingly. If string @var{sch} contain @samp{#} then wire plot is produced. If string @var{sch} have symbol @samp{.} then plot by dots is produced. Note, you can use @ref{map}-like coloring if use @samp{%} in color scheme. See also @ref{surf3}, @ref{surfca}, @ref{surf3c}, @ref{surf3a}. @sref{surf3ca sample}
@end deftypefn

@deftypefn {MGL command} {} surf3ca adat cdat bdat ['sch'='']
@deftypefnx {MGL command} {} surf3ca xdat ydat zdat adat cdat bdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3CA (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3CA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3ca (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3ca_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. Here parameter @var{num} is equal to parameter @code{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{tiles}
@deftypefn {MGL command} {} tiles zdat rdat ['sch'='']
@deftypefnx {MGL command} {} tiles xdat ydat zdat rdat ['sch'='']
@deftypefnx {MGL command} {} tiles xdat ydat zdat rdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tiles (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tiles_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tiles_xyc (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. It is mostly the same as @ref{tile} but the size of tiles is determined by @var{r} array. If string @var{sch} contain style @samp{x} or @samp{y} then tiles will be oriented perpendicular to x- or y-axis. This is some kind of ``transparency'' useful for exporting to EPS files. Tiles is plotted for each z slice of the data. See also @ref{surfa}, @ref{tile}. @sref{tiles sample}
@end deftypefn

@anchor{map}
@deftypefn {MGL command} {} map udat vdat ['sch'='']
@deftypefnx {MGL command} {} map xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Map (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Map (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_map (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_map_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The initial position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ??? If string @var{sch} contain symbol @samp{.} then the color ball at matrix knots are drawn otherwise face is drawn. @sref{Mapping visualization}
@end deftypefn

@anchor{stfa}
@deftypefn {MGL command} {} stfa re im @code{dn} ['sch'='']
@deftypefnx {MGL command} {} stfa xdat ydat re im @code{dn} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} STFA (@code{const mglDataA &}re, @code{const mglDataA &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} STFA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}re, @code{const mglDataA &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_stfa (@code{HMGL} gr, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws spectrogram of complex array @var{re}+i*@var{im} for Fourier size of @var{dn} points at plane @var{z} equal to minimal z-axis value. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}).  @sref{stfa sample}
@end deftypefn


@c ##################################################################
@external{}
@node Vector fields, Other plotting, Dual plotting, MathGL core
@section Vector fields
@nav{}
@cindex Traj
@cindex Vect
@cindex Dew
@cindex Flow
@cindex FlowP
@cindex Pipe

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vectors along the curve (Traj), vector field by dew-drops (Dew), flow threads (Flow, FlowP), flow pipes (Pipe). By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{ax} should be equal. The size of @var{ax}, @var{ay} and @var{az} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not matrices as @var{ax}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. String @var{opt} contain command options (see @ref{Command options}).

@anchor{traj}
@deftypefn {MGL command} {} traj xdat ydat udat vdat ['sch'='']
@deftypefnx {MGL command} {} traj xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Traj (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Traj (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_traj_xyz (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}z, @code{HCDT}ax, @code{HCDT}ay, @code{HCDT}az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_traj_xy (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}ax, @code{HCDT}ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vectors @{@var{ax}, @var{ay}, @var{az}@} along a curve @{@var{x}, @var{y}, @var{z}@}. The length of arrows are proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. String @var{pen} specifies the color (see @ref{Line styles}). By default (@code{pen=""}) color from palette is used (see @ref{Palette and colors}). Option @code{value} set the vector length factor (if non-zero) or vector length to be proportional the distance between curve points (if @code{value=0}). The minor sizes of all arrays must be equal and large 2. The plots are drawn for each row if one of the data is the matrix. See also @ref{vect}. @sref{traj sample}
@end deftypefn

@anchor{vect}
@deftypefn {MGL command} {} vect udat vdat ['sch'='']
@deftypefnx {MGL command} {} vect xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_vect_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_vect_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z} equal to minimal z-axis value. The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of arrows depend on @ref{meshnum}. The appearance of the hachures (arrows) can be changed by symbols:
@itemize @bullet
@item
@samp{f} for drawing arrows with fixed lengths,
@item
@samp{>}, @samp{<} for drawing arrows to or from the cell point (default is centering),
@item
@samp{.} for drawing hachures with dots instead of arrows,
@item
@samp{=} for enabling color gradient along arrows.
@end itemize
See also @ref{flow}, @ref{dew}. @sref{vect sample}
@end deftypefn

@deftypefn {MGL command} {} vect udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} vect xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_vect_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_vect_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length and color of arrows is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@anchor{vect3}
@deftypefn {MGL command} {} vect3 udat vdat wdat ['sch'='' sval]
@deftypefnx {MGL command} {} vect3 xdat ydat zdat udat vdat wdat ['sch'='' sval]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect3 (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_vect3 (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_vect3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
The function draws 3D vector field plot for the field @{@var{ax}, @var{ay}, @var{az}@} depending parametrically on coordinates @var{x}, @var{y}, @var{z}. Vector field is drawn at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. The number of arrows depend on @ref{meshnum}. The appearance of the hachures (arrows) can be changed by symbols:
@itemize @bullet
@item
@samp{f} for drawing arrows with fixed lengths,
@item
@samp{>}, @samp{<} for drawing arrows to or from the cell point (default is centering),
@item
@samp{.} for drawing hachures with dots instead of arrows,
@item
@samp{=} for enabling color gradient along arrows.
@end itemize
See also @ref{vect}, @ref{flow}, @ref{dew}. @sref{vect3 sample}
@end deftypefn

@anchor{dew}
@deftypefn {MGL command} {} dew udat vdat ['sch'='']
@deftypefnx {MGL command} {} dew xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dew (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dew (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dew (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dew_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z} equal to minimal z-axis value. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @ref{meshnum}. See also @ref{vect}. @sref{dew sample}
@end deftypefn

@anchor{flow}
@deftypefn {MGL command} {} flow udat vdat ['sch'='']
@deftypefnx {MGL command} {} flow xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flow_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flow_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level @var{z} equal to minimal z-axis value. Option @code{value} set the approximate number of threads (default is 5), or accuracy for stationary points (if style @samp{.} is used) . String @var{sch} may contain:
@itemize @bullet
@item
color scheme -- up-half (warm) corresponds to normal flow (like attractor), bottom-half (cold) corresponds to inverse flow (like source);
@item
@samp{#} for starting threads from edges only;
@item
@samp{.} for drawing separatrices only (flow threads to/from stationary points).
@item
@samp{*} for starting threads from a 2D array of points inside the data;
@item
@samp{v} for drawing arrows on the threads;
@item
@samp{x}, @samp{z} for drawing tapes of normals in x-y and y-z planes correspondingly.
@end itemize
See also @ref{pipe}, @ref{vect}, @ref{tape}, @ref{flow3}, @ref{barwidth}. @sref{flow sample}
@end deftypefn

@deftypefn {MGL command} {} flow udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} flow xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flow_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flow_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@deftypefn {MGL command} {} flow @code{x0 y0} udat vdat ['sch'='']
@deftypefnx {MGL command} {} flow @code{x0 y0} xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_2d (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flowp_xy (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as first one (@ref{flow}) but draws single flow thread starting from point @var{p0}=@{@var{x0},@var{y0},@var{z0}@}. String @var{sch} may also contain: @samp{>} or @samp{<} for drawing in forward or backward direction only (default is both).
@end deftypefn

@deftypefn {MGL command} {} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_3d (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flowp_xyz (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the previous functions.
@end deftypefn

@anchor{flow3}
@deftypefn {MGL command} {} flow3 udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} flow3 xdat ydat zdat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow3 (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{double} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{double} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flow3 (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{double} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flow3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{double} sVal, @code{const char *}opt)
@end ifclear
The function draws flow threads for the 3D vector field @{@var{ax}, @var{ay}, @var{az}@} parametrically depending on coordinates @var{x}, @var{y}, @var{z}. Flow threads starts from given plane. Option @code{value} set the approximate number of threads (default is 5). String @var{sch} may contain:
@itemize @bullet
@item
color scheme -- up-half (warm) corresponds to normal flow (like attractor), bottom-half (cold) corresponds to inverse flow (like source);
@item
@samp{x}, @samp{z} for normal of starting plane (default is y-direction);
@item
@samp{v} for drawing arrows on the threads;
@item
@samp{t} for drawing tapes of normals in x-y and y-z planes.
@end itemize
See also @ref{flow}, @ref{pipe}, @ref{vect}. @sref{flow3 sample}
@end deftypefn


@anchor{grad}
@deftypefn {MGL command} {} grad pdat ['sch'='']
@deftypefnx {MGL command} {} grad xdat ydat pdat ['sch'='']
@deftypefnx {MGL command} {} grad xdat ydat zdat pdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grad (@code{HMGL} gr, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grad_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grad_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws gradient lines for scalar field @var{phi}[i,j] (or @var{phi}[i,j,k] in 3d case) specified parametrically @{@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]@}. Number of lines is proportional to @code{value} option (default is 5). See also @ref{dens}, @ref{cont}, @ref{flow}.
@end deftypefn

@anchor{pipe}
@deftypefn {MGL command} {} pipe udat vdat ['sch'='' @code{r0=0.05}]
@deftypefnx {MGL command} {} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_pipe_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pipe_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@end ifclear
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level @var{z} equal to minimal z-axis value. Number of pipes is proportional to @code{value} option (default is 5). If @samp{#} symbol is specified then pipes start only from edges of axis range. The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). Parameter @var{r0} set the base pipe radius. If @var{r0}<0 or symbol @samp{i} is specified then pipe radius is inverse proportional to amplitude. The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{flow}, @ref{vect}. @sref{pipe sample}
@end deftypefn

@deftypefn {MGL command} {} pipe udat vdat wdat ['sch'='' @code{r0=0.05}]
@deftypefnx {MGL command} {} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_pipe_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pipe_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn


@c ##################################################################
@external{}
@node Other plotting, Nonlinear fitting, Vector fields, MathGL core
@section Other plotting
@nav{}
@cindex DensXYZ
@cindex ContXYZ
@cindex ContFXYZ
@cindex Dots
@cindex Crust
@cindex TriPlot
@cindex TriCont
@cindex QuadPlot
@cindex FPlot
@cindex FSurf

These functions perform miscellaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular or quadrangular mesh (TriPlot, TriCont, QuadPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@anchor{densz} @anchor{densy} @anchor{densx} @anchor{DensXYZ}
@deftypefn {MGL command} {} densx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} densy dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} densz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} DensX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} DensY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} DensZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dens_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{dens}, @ref{Data manipulation}. @sref{dens_xyz sample}
@end deftypefn

@anchor{contz} @anchor{conty} @anchor{contx} @anchor{ContXYZ}
@deftypefn {MGL command} {} contx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} conty dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw contour lines in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. Option @code{value} set the number of contours. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{cont_xyz sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} ContX (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContY (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContZ (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
The same as previous with manual contour levels.
@end deftypefn
@end ifclear

@anchor{contfz} @anchor{contfy} @anchor{contfx} @anchor{ContFXYZ}
@deftypefn {MGL command} {} contfx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contfy dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contfz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw solid contours in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. Option @code{value} set the number of contours. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{contf_xyz sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} ContFX (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFY (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFZ (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
The same as previous with manual contour levels.
@end deftypefn
@end ifclear

@anchor{fplot}
@deftypefn {MGL command} {} fplot 'y(x)' ['pen'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FPlot (@code{const char *}eqY, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fplot (@code{HMGL} gr, @code{const char *}eqY, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Draws command function @samp{y(x)} at plane @var{z} equal to minimal z-axis value, where @samp{x} variable is changed in @code{xrange}. You do not need to create the data arrays to plot it. Option @code{value} set initial number of points.  See also @ref{plot}.
@end deftypefn

@deftypefn {MGL command} {} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FPlot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fplot_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Draws command parametrical curve @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@} where @samp{t} variable is changed in range [0, 1]. You do not need to create the data arrays to plot it. Option @code{value} set number of points. See also @ref{plot}.
@end deftypefn

@anchor{fsurf}
@deftypefn {MGL command} {} fsurf 'z(x,y)' ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FSurf (@code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""});
@deftypefnx {C function} @code{void} mgl_fsurf (@code{HMGL} gr, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt);
@end ifclear
Draws command surface for function @samp{z(x,y)} where @samp{x}, @samp{y} variable are changed in @code{xrange, yrange}. You do not need to create the data arrays to plot it. Option @code{value} set number of points. See also @ref{surf}.
@end deftypefn

@deftypefn {MGL command} {} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FSurf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fsurf_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws command parametrical surface @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@} where @samp{u}, @samp{v} variable are changed in range [0, 1]. You do not need to create the data arrays to plot it. Option @code{value} set number of points. See also @ref{surf}.
@end deftypefn

@anchor{triplot}
@deftypefn {MGL command} {} triplot idat xdat ydat ['sch'='']
@deftypefnx {MGL command} {} triplot idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} triplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_triplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_triplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_triplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{dots}, @ref{crust}, @ref{quadplot}, @ref{triangulation}. @sref{triplot sample}
@end deftypefn

@anchor{tricont}
@deftypefn {MGL command} {} tricont vdat idat xdat ydat zdat cdat ['sch'='']
@deftypefnx {MGL command} {} tricont vdat idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} tricont idat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TriCont (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriCont (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriContV (@code{const mglDataA &}v, @code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriContV (@code{const mglDataA &}v, @code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tricont_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyzcv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyzv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws contour lines for surface of triangles at @var{z}=@var{v}[k] (or at  @var{z} equal to minimal z-axis value if @var{sch} contain symbol @samp{_}). Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If @var{v} is absent then arrays of option @code{value} elements  equidistantly distributed in color range is used. String @var{sch} sets the color scheme. Array @var{c} (if specified) is used for contour coloring. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{triplot}, @ref{cont}, @ref{triangulation}.
@end deftypefn

@anchor{quadplot}
@deftypefn {MGL command} {} quadplot idat xdat ydat ['sch'='']
@deftypefnx {MGL command} {} quadplot idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} quadplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_quadplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_quadplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_quadplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the surface of quadrangles. Quadrangles vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 4 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of quadrangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{triplot}. @sref{triplot sample}
@end deftypefn

@anchor{dots}
@deftypefn {MGL command} {} dots xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} dots xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dots (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dots_a (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dots_ca (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme and kind of marks. If arrays @var{c}, @var{a} are specified then they define colors and transparencies of dots. You can use @ref{tens} plot with style @samp{ .} to draw non-transparent dots with specified colors. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also @ref{crust}, @ref{tens}, @ref{mark}, @ref{plot}. @sref{dots sample}
@end deftypefn

@anchor{crust}
@deftypefn {MGL command} {} crust xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Crust (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_crust (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{dots}, @ref{triplot}. @c @sref{crust sample}
@end deftypefn

@c ##################################################################
@external{}
@node Nonlinear fitting, Data manipulation, Other plotting, MathGL core
@section Nonlinear fitting
@nav{}
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex mglFitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (see @ref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return it. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the axis range. Number of points in @var{fit} is defined by option @code{value} (default is @var{mglFitPnts}=100). Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Nonlinear fitting hints}

@anchor{fits}
@deftypefn {MGL command} {} fits res adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat ydat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat ydat zdat adat sdat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_ys (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xys (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyzs (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyzas (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
Fit data along x-, y- and z-directions for array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with weight factor @var{s}[i,j,k].
@end deftypefn

@anchor{fit}
@deftypefn {MGL command} {} fit res adat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat adat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat ydat adat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat ydat zdat adat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyza (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
Fit data along x-, y- and z-directions for array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with weight factor 1.
@end deftypefn


@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{mglData} Fit2 (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit2 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_2 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
Fit data along all directions for 2d or 3d arrays @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in axis range.
@end deftypefn
@end ifclear

@anchor{putsfit}
@deftypefn {MGL command} {} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{""}, @code{const char *}font=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_fit (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}prefix, @code{const char *}font, @code{mreal} size)
@end ifclear
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{const char *}GetFit ()
@deftypefnx {C function only} @code{const char *} mgl_get_fit (@code{HMGL} gr)
@deftypefnx {Fortran subroutine} @code{} mgl_get_fit (@code{long} gr, @code{char *}out, @code{int} len)
Get last fitted formula with found coefficients (as numbers).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{mreal} GetFitChi ()
@deftypefnx {C function} @code{mreal} mgl_get_fit_chi ()
Get \chi for last fitted formula.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{mreal} GetFitCovar ()
@deftypefnx {C function} @code{mreal} mgl_get_fit_covar ()
Get covariance matrix for last fitted formula.
@end deftypefn
@end ifclear


@c ##################################################################
@external{}
@node Data manipulation, , Nonlinear fitting, MathGL core
@section Data manipulation
@nav{}
@cindex Hist
@cindex Fill
@cindex DataGrid

@deftypefn {MGL command} {} hist @sc{res} xdat adat
@deftypefnx {MGL command} {} hist @sc{res} xdat ydat adat
@deftypefnx {MGL command} {} hist @sc{res} xdat ydat zdat adat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_hist_x (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_hist_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_hist_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}opt)
@end ifclear
These functions make distribution (histogram) of data. They do not draw the obtained data themselves. These functions can be useful if user have data defined for random points (for example, after PIC simulation) and he want to produce a plot which require regular data (defined on grid(s)). The range for grids is always selected as axis range. Arrays @var{x}, @var{y}, @var{z} define the positions (coordinates) of random points. Array @var{a} define the data value. Number of points in output array @var{res}  is defined by option @code{value} (default is @var{mglFitPnts}=100).
@end deftypefn


@deftypefn {MGL command} {} fill dat 'eq'
@deftypefnx {MGL command} {} fill dat 'eq' vdat
@deftypefnx {MGL command} {} fill dat 'eq' vdat wdat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglDataA &}v, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglDataA &}v, @code{const mglDataA &}w, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_data_fill_eq (@code{HMGL} gr, @code{HMDT} u, @code{const char *}eq, @code{HCDT}v, @code{HCDT}w, @code{const char *}opt)
@end ifclear
Fills the value of array @samp{u} according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in axis range. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of arrays @var{v}, @var{w} which can be @code{NULL} (i.e. can be omitted).
@end deftypefn

@deftypefn {MGL command} {} datagrid dat xdat ydat zdat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} DataGrid (@code{mglData &}u, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_data_grid (@code{HMGL} gr, @code{HMDT} u, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}opt)
@end ifclear
Fills the value of array @samp{u} according to the linear interpolation of triangulated surface, found for arbitrary placed points @samp{x}, @samp{y}, @samp{z}. Interpolation is done at points equidistantly distributed in axis range. NAN value is used for grid points placed outside of triangulated surface. @sref{Making regular data}
@end deftypefn

@deftypefn {MGL command} {} refill dat xdat vdat [sl=-1]
@deftypefnx {MGL command} {} refill dat xdat ydat vdat [sl=-1]
@deftypefnx {MGL command} {} refill dat xdat ydat zdat vdat
@ifclear UDAV
@deftypefnx {Method on @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}v, @code{long} sl=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}v, @code{long} sl=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}v, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_data_refill_gr (@code{HMGL} gr, @code{HMDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} v, @code{long} sl, @code{const char *}opt)
@end ifclear
Fills by interpolated values of array @var{v} at the point @{@var{x}, @var{y}, @var{z}@}=@{@code{X[i], Y[j], Z[k]}@} (or @{@var{x}, @var{y}, @var{z}@}=@{@code{X[i,j,k], Y[i,j,k], Z[i,j,k]}@} if @var{x}, @var{y}, @var{z} are not 1d arrays), where @code{X,Y,Z} are equidistantly distributed in axis range and have the same sizes as array @var{dat}. If parameter @var{sl} is 0 or positive then changes will be applied only for slice @var{sl}.
@end deftypefn


@deftypefn {MGL command} {} pde @sc{res} 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} PDE (@code{const char *}ham, @code{const mglDataA &}ini_re, @code{const mglDataA &}ini_im, @code{mreal} dz=@code{0.1}, @code{mreal} k0=@code{100}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_pde_solve (@code{HMGL} gr, @code{const char *}ham, @code{HCDT} ini_re, @code{HCDT} ini_im, @code{mreal} dz, @code{mreal} k0, @code{const char *}opt)
@end ifclear
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in axis range. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. You may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE solving hints}
@end deftypefn

@c ##################################################################
@c @external{}
@c @node IDTF functions, , Data manipulation, MathGL core
@c @section IDTF functions
@c @nav{}

@c These functions provide IDTF specific features. In all other cases they do nothing.

@c @ifclear UDAV

@c @deftypefn {Method on @code{mglGraph}} @code{void} VertexColor (@code{bool} enable)
@c Enables smooth color change.
@c @end deftypefn

@c @deftypefn {Method on @code{mglGraph}} @code{void} Compression (@code{bool} enable)
@c Gives smaller files, but quality degrades.
@c @end deftypefn

@c inline void DoubleSided(bool){}	// NOTE: Add later -- IDTF
@c inline void TextureColor(bool){}	// NOTE: Add later -- IDTF

@c @end ifclear

@external{}
